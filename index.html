<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>xingtangcunliu个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xingtangcunliu个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xingtangcunliu个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xingtangcunliu个人博客">
  
    <link rel="alternate" href="/atom.xml" title="xingtangcunliu个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xingtangcunliu个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-View-Context-leak" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/View-Context-leak/" class="article-date">
  <time datetime="2016-11-08T16:24:50.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/View-Context-leak/">Android 输入法导致内存泄露以及WebView内存泄露解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果开发到一定程度肯定会去处理内存的问题，因为不处理该问题的话，轻一点会导致应用频繁GC，严重的情况下会产生内存溢出导致崩溃。而只要讲到内存溢出经常会遇到一句话，使用Activity的Context导致，而Context被引用，最后导致Activity泄露。</p>
<h2 id="1、查找泄露原因"><a href="#1、查找泄露原因" class="headerlink" title="1、查找泄露原因"></a>1、查找泄露原因</h2><p>既然是查询View持有Activity的引用导致的内存泄露，那么就从Activity的setContentView看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过代码一步一步查找，发现最后是实现了PhoneWindow的setContentView的方法。PhoneWindow位于\frameworks\base\policy\src\com\android\internal\policy\impl\PhoneWondow.java;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">    // before this happens.</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        installDecor();</div><div class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        mContentParent.removeAllViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                getContext());</div><div class="line">        transitionTo(newScene);</div><div class="line">    &#125; else &#123;</div><div class="line">        //最后还是在这里实现，如果mContentParent不为null，mContentParent直接把layoutResID的布局添加到根布局</div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">    &#125;</div><div class="line">    mContentParent.requestApplyInsets();</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看见Activity的setContentView（int layoutRes）最后还是用LayoutInflater实现了。那我们再看mLayoutInflater是什么时候生成的，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public PhoneWindow(Context context) &#123;</div><div class="line">    super(context);</div><div class="line">    mLayoutInflater = LayoutInflater.from(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出是在PhoneWindow生成时一起生成的，那么PhoneWindow什么生成的，继续看Activityd的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">           Instrumentation instr, IBinder token, int ident,</div><div class="line">           Application application, Intent intent, ActivityInfo info,</div><div class="line">           CharSequence title, Activity parent, String id,</div><div class="line">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">           Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</div><div class="line">       attachBaseContext(context);</div><div class="line"></div><div class="line">       mFragments.attachHost(null /*parent*/);</div><div class="line">       //这里可以看出把Activity当成Context传给PhoneWindow了，并用这个Context生成了LayoutInflater。</div><div class="line">       mWindow = new PhoneWindow(this);</div><div class="line">      ....</div><div class="line">      省略</div><div class="line">      ....</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到Activity传递到了PhoneWindow，并通过Activity生成了LayoutInflater。这里记住，下面分析时要用到。</p>
<p>既然是Activity被View持有，那么我们就从View何时被赋值Context出发。那么我先列出View有多少种生成方法。<br>1、构造函数生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public View(Context context) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对构造函数生成，可以看出在这个方法中我们可以直接控制Context,也就是说我们自己可以控制是否直接使用Activity，可以直接使用Application，当然会出些问题，原因以及解决方法下面再说。</p>
<p>2、LayoutInflater方法生成</p>
<p>然后再看LayoutInflater如何生成View，在这之前我先找到LayoutInflater的实现类，因为你会发现LayoutInflater是抽象的。现在从LayoutInflater的生成方法开始看起。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Obtains the LayoutInflater from the given context.</div><div class="line">    */</div><div class="line">   public static LayoutInflater from(Context context) &#123;</div><div class="line">       LayoutInflater LayoutInflater =</div><div class="line">               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">       <span class="keyword">if</span> (LayoutInflater == null) &#123;</div><div class="line">           throw new AssertionError(<span class="string">"LayoutInflater not found."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="built_in">return</span> LayoutInflater;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用context的getSystemService方法，一直往上找会发现最后调用了ContextImpl的getSystemService的方法。<br>LayoutInflater实例化的地方为ContextImpl,位于\frameworks\base\core\java\android\app\ContextImpl.java。代码为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line"> ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line"> registerService(LAYOUT_INFLATER_SERVICE, new <span class="function"><span class="title">ServiceFetcher</span></span>() &#123;</div><div class="line">                public Object createService(ContextImpl ctx) &#123;</div><div class="line">                    <span class="built_in">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</div><div class="line">                &#125;&#125;);</div><div class="line"> ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过一步一步的代码跟踪，发现了LayoutInflater的实现类BridgeInflater,位于frameworks\base\tools\layoutlib\bridge\src\android\view\BridgeInflater.java,在这我们只需要关心onCreateView方法。<br>最后调用PolicyManager的makeNewLayoutInflater方法生成，同时传入ctx.getOuterContext()，这就是LayoutInflater所持有的Context，这就是ContextImpl生成时传入ContextImpl的Context。ContextImpl的对象生成代码位于\frameworks\base\core\java\android\app\ActivityThread.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private Context createBaseContextForActivity(ActivityClientRecord r,</div><div class="line">            final Activity activity) &#123;</div><div class="line">        生成ContextImpl并把Activity通过setOuterContext方法赋值给ContextImpl。</div><div class="line">        ContextImpl appContext = new ContextImpl();</div><div class="line">        appContext.init(r.packageInfo, r.token, this);</div><div class="line">        appContext.setOuterContext(activity);</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">        return baseContext;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出Activity和ContextImpl互相持有，那么Application和ContextImpl也互相持有。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line">public final class BridgeInflater extends LayoutInflater &#123;</div><div class="line"></div><div class="line">    private final IProjectCallback mProjectCallback;</div><div class="line">    private boolean mIsInMerge = <span class="literal">false</span>;</div><div class="line">    private ResourceReference mResourceReference;</div><div class="line"></div><div class="line">    private static final String[] sClassPrefixList = &#123;</div><div class="line">        <span class="string">"android.widget."</span>,</div><div class="line">        <span class="string">"android.webkit."</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    protected BridgeInflater(LayoutInflater original, Context newContext) &#123;</div><div class="line">        //把Context传递给LayoutInflater父类</div><div class="line">        super(original, newContext);</div><div class="line">        mProjectCallback = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BridgeInflater(Context context, IProjectCallback projectCallback) &#123;</div><div class="line">        //把Context传递给LayoutInflater父类</div><div class="line">        super(context);</div><div class="line">        mProjectCallback = projectCallback;</div><div class="line">        mConstructorArgs[0] = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123;</div><div class="line">        View view = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">                try &#123;</div><div class="line">                    //调用LayoutInflater的createView方法</div><div class="line">                    view = createView(name, prefix, attrs);</div><div class="line">                    <span class="keyword">if</span> (view != null) &#123;</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                    // Ignore. We<span class="string">'ll try again using the base class below.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                if (view == null) &#123;</div><div class="line">                    view = super.onCreateView(name, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                // Ignore. We'll try again using the custom view loader below.</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Finally try again using the custom view loader</div><div class="line">            try &#123;</div><div class="line">                <span class="keyword">if</span> (view == null) &#123;</div><div class="line">                    view = loadCustomView(name, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                // If the class was not found, we throw the exception directly, because this</div><div class="line">                // method is already expected to throw it.</div><div class="line">                throw e;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            // Wrap the real exception <span class="keyword">in</span> a ClassNotFoundException, so that the calling method</div><div class="line">            // can deal with it.</div><div class="line">            ClassNotFoundException exception = new ClassNotFoundException(<span class="string">"onCreateView"</span>, e);</div><div class="line">            throw exception;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setupViewInContext(view, attrs);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View createViewFromTag(View parent, String name, AttributeSet attrs) &#123;</div><div class="line">        View view = null;</div><div class="line">        try &#123;</div><div class="line">            //调用LayoutInflater的createViewFromTag方法</div><div class="line">            view = super.createViewFromTag(parent, name, attrs);</div><div class="line">        &#125; catch (InflateException e) &#123;</div><div class="line">            // try to load the class from using the custom view loader</div><div class="line">            try &#123;</div><div class="line">                view = loadCustomView(name, attrs);</div><div class="line">            &#125; catch (Exception e2) &#123;</div><div class="line">                // Wrap the real exception <span class="keyword">in</span> an InflateException so that the calling</div><div class="line">                // method can deal with it.</div><div class="line">                InflateException exception = new InflateException();</div><div class="line">                <span class="keyword">if</span> (e2.getClass().equals(ClassNotFoundException.class) == <span class="literal">false</span>) &#123;</div><div class="line">                    exception.initCause(e2);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    exception.initCause(e);</div><div class="line">                &#125;</div><div class="line">                throw exception;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setupViewInContext(view, attrs);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View inflate(int resource, ViewGroup root) &#123;</div><div class="line">        Context context = getContext();</div><div class="line">        <span class="keyword">if</span> (context instanceof BridgeContext) &#123;</div><div class="line">            BridgeContext bridgeContext = (BridgeContext)context;</div><div class="line"></div><div class="line">            ResourceValue value = null;</div><div class="line"></div><div class="line">            Pair&lt;ResourceType, String&gt; layoutInfo = Bridge.resolveResourceId(resource);</div><div class="line">            <span class="keyword">if</span> (layoutInfo != null) &#123;</div><div class="line">                value = bridgeContext.getRenderResources().getFrameworkResource(</div><div class="line">                        ResourceType.LAYOUT, layoutInfo.getSecond());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                layoutInfo = mProjectCallback.resolveResourceId(resource);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (layoutInfo != null) &#123;</div><div class="line">                    value = bridgeContext.getRenderResources().getProjectResource(</div><div class="line">                            ResourceType.LAYOUT, layoutInfo.getSecond());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (value != null) &#123;</div><div class="line">                File f = new File(value.getValue());</div><div class="line">                <span class="keyword">if</span> (f.isFile()) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        XmlPullParser parser = ParserFactory.create(f);</div><div class="line"></div><div class="line">                        BridgeXmlBlockParser bridgeParser = new BridgeXmlBlockParser(</div><div class="line">                                parser, bridgeContext, <span class="literal">false</span>);</div><div class="line">                        //调用LayoutInflater的inflate方法</div><div class="line">                        <span class="built_in">return</span> inflate(bridgeParser, root);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ,</div><div class="line">                                <span class="string">"Failed to parse file "</span> + f.getAbsolutePath(), e, null /*data*/);</div><div class="line"></div><div class="line">                        <span class="built_in">return</span> null;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">  ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后还是会调用LayoutInflater的inflate的方法；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123;</div><div class="line">   <span class="built_in">return</span> inflate(parser, root, root != null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></div><div class="line">                 + Integer.toHexString(resource) + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    //获取页面的xml资源解析</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        //解析xml资源文件</div><div class="line">        <span class="built_in">return</span> inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Context inflaterContext = mContext;</div><div class="line">    final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">    Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">    //设置View构造函数的参数，设置Context参数为LayoutInflater自带的context，下面createView方法会使用到。</div><div class="line">    mConstructorArgs[0] = inflaterContext;</div><div class="line">    ....</div><div class="line">    省略</div><div class="line">    ....</div><div class="line">    //创建View</div><div class="line">    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line">    ....</div><div class="line">    省略</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码就是创建的一下流程，可以看出View是LayoutInflater创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;</div><div class="line">    return createViewFromTag(parent, name, context, attrs, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">      ....</div><div class="line">       省略</div><div class="line">      ....</div><div class="line">        //View 最后调用了onCreateView方法生成了View，mFactory2、mFactory默认为null，最后会调用onCreateView方法。</div><div class="line">        View view;</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还是到了createView方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static final Class&lt;?&gt;[] mConstructorSignature = new Class[] &#123;</div><div class="line">        Context.class, AttributeSet.class&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line"></div><div class="line">        //获取默认构造，使用View(Context context, @Nullable AttributeSet attrs)</div><div class="line">        constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">        constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">        sConstructorMap.put(name, constructor);</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //此处args参数中args[0]已结设置为LayoutInflater,上面中已经提及。</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        <span class="keyword">if</span> (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(<span class="built_in">clone</span>InContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line"></div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面分析可以看出最后和View绑定的Context就是LayoutInflater所持有的Context。这时我们就要着重分析LayoutInflater持有的Context到底是不是Context，如果是那么是什么时候赋值的，那我们再研究一下LayoutInflater的生成方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static LayoutInflater from(Context context) &#123;</div><div class="line">    LayoutInflater LayoutInflater =</div><div class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    if (LayoutInflater == null) &#123;</div><div class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</div><div class="line">    &#125;</div><div class="line">  return LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果研究过Activity和Application的源码我们会发现Activity的源码继承类比Activity多了一层，那就是Activity继承于ContextThemeWrapper，而Application继承于ContextWrapper，他们都对getSystemService方法进行了重写，ContextThemeWrapper的重写代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override public Object getSystemService(String name) &#123;</div><div class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</div><div class="line">        if (mInflater == null) &#123;</div><div class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);</div><div class="line">        &#125;</div><div class="line">        return mInflater;</div><div class="line">    &#125;</div><div class="line">    return getBaseContext().getSystemService(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而ContextWrapper重写的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return mBase.getSystemService(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ContextThemeWrapper继承于ContextWrapper，而getBaseContext()方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Context getBaseContext() &#123;</div><div class="line">   return mBase;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出ContextThemeWrapper和ContextWrapper最终实现除了cloneInContext方法外都一样，最终都是通过自己持有的ContextImpl对象执行getSystemService方法来获取LayoutInflater对象。而前面分析可知最终都会用ContextImpl对象所持有的mOuterContext对象，即Application和Activity生成LayoutInflater对象，进而LayoutInflater对象持有Activity或Application。我们在看一下ContextThemeWrapper重写中用到的cloneInContext方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public LayoutInflater cloneInContext(Context newContext) &#123;</div><div class="line">      return new BridgeInflater(this, newContext);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出该方法的作用就是克隆，只是把新生成LayoutInflater对象的Context对象替换掉。其实我有点不明白，因为ContextImpl方法中生成LayoutInflater用到的Context就是Activity本身，为什么还要这一步。到这一步可以很容易的看出View为什么会持有Activity了。逻辑整理如下：</p>
<p>PhoneWindow 用Activity生成LayoutInflater</p>
<p>LayoutInflater对象持有Activity；</p>
<p>LayoutInflater在生成View对象时把Activity赋值给View，</p>
<p>View 持有Activity的引用。</p>
<p>##2、解决方案##</p>
<p>我的思路很简单既然是因为View持有Activity的引用，那就不让Activity的强引用就可以了。</p>
<p>从以上代码分析可以看出Activity之所以会被持有都是因为PhoneWindow中生成LayoutInflater对象调用了Activity的getSystemService方法。该方法生成的对象持有Activity对象的引用。一开始我准备直接在BaseActivity中重写的getSystemService方法。最早为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> public Object getSystemService(String name) &#123;</div><div class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</div><div class="line">        if (mInflater == null) &#123;</div><div class="line">            //使用代理类</div><div class="line">            baseContextWrappernew = new BaseContextWrapper(this);</div><div class="line">            mInflater = LayoutInflater.from(BaseApplication.getInstance());</div><div class="line">        &#125;</div><div class="line">        return mInflater;</div><div class="line">    &#125;</div><div class="line">return super.getSystemService(name);</div></pre></td></tr></table></figure>
<p>但这种方法有个严重的问题，就是Activity的很多主题样式不能使用了，所以有看了ContextThemeWrapper的方法，自己继承ContextWrapper类，重写其中的几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">//创建代理类</div><div class="line">public class BaseContextWrapper extends ContextWrapper &#123;</div><div class="line"></div><div class="line">    static Field field;</div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            field = ContextWrapper.class.getDeclaredField(&quot;mBase&quot;);</div><div class="line">            field.setAccessible(true);</div><div class="line">        &#125; catch (NoSuchFieldException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Context mContext;</div><div class="line">    public BaseContextWrapper(Context context) &#123;</div><div class="line">        super(null);</div><div class="line">        mContext = context;</div><div class="line">        if(context instanceof ContextWrapper)&#123;</div><div class="line">            context = ((ContextWrapper)context).getBaseContext();</div><div class="line">        &#125;</div><div class="line">        attachBaseContext(context);</div><div class="line">    &#125;</div><div class="line">    //当获取主题信息时直接调用Activity的getTheme方法。</div><div class="line">    @Override</div><div class="line">    public Resources.Theme getTheme() &#123;</div><div class="line">        if(mContext != null)&#123;</div><div class="line">            return mContext.getTheme();</div><div class="line">        &#125;</div><div class="line">        return super.getTheme();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public Object getSystemService(String name) &#123;</div><div class="line">        if(mContext == null)&#123;</div><div class="line">            return super.getSystemService(name);</div><div class="line">        &#125;</div><div class="line">        return mContext.getSystemService(name);</div><div class="line">    &#125;</div><div class="line">    //释放Activity的持有。</div><div class="line">    public void recycle()&#123;</div><div class="line">        try &#123;</div><div class="line">            field.set(this,null);</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Activity getActivityContext()&#123;</div><div class="line">        Activity context = (Activity) mContext;</div><div class="line">        return context;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样View就只会持有BaseContextWrapper对象，当Activity销毁时会执行recycle方法释放Activity已经ContextImpl。这样View已经不能直接持有Activity了，但还有一个问题就是View本身持有包含它的ViewGroup就是ViewParent，这里只需要去除持有关系即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();</div><div class="line">//去除方法要在BaseContextWrapper的recycle方法之前执行。</div><div class="line">clearView(viewGroup);</div><div class="line">if(baseContextWrappernew != null)&#123;</div><div class="line">   baseContextWrappernew.recycle();</div><div class="line">&#125;</div><div class="line">private void clearView(View viewClear)&#123;</div><div class="line">    if(viewClear instanceof ViewGroup)&#123;</div><div class="line">        int length = ((ViewGroup)viewClear).getChildCount();</div><div class="line">        View view = null;</div><div class="line">        for(int i=0;i&lt; length;i++)&#123;</div><div class="line">            view = ((ViewGroup) viewClear).getChildAt(i);</div><div class="line">            clearView(view);</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">           ((ViewGroup) viewClear).removeAllViews();</div><div class="line">        &#125; catch(Exception e)&#123;</div><div class="line">        &#125;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些只是清楚了VIew和Activity的基本持有关系，但各种事件监听之类的要自己注意去除。</p>
<p>##3、LayoutInflater 的Activity or Application##<br>从我上面的分析其实已经可以看出了部分区别。</p>
<p>1、就是用Activity那么View持有的Context就是Activity，如果用的是Application那么View持有的Context就是Application，而有些人比较喜欢直接用View的Context转为Activity，如果用Application那时就会出错。<br>2、Application继承自ContextWrapper，而Activity继承自ContextThemeWrapper，而ContextThemeWrapper有时对ContextWrapper的继承，对其中一部分方法进行了修改，这也就是不同所在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//在Activity生成时会获取Activity的主题，并调用该方法</div><div class="line"> @Override public void setTheme(int resid) &#123;</div><div class="line">        mThemeResource = resid;</div><div class="line">        initializeTheme();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /** @hide */</div><div class="line">    @Override</div><div class="line">    public int getThemeResId() &#123;</div><div class="line">        return mThemeResource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public Resources.Theme getTheme() &#123;</div><div class="line">        if (mTheme != null) &#123;</div><div class="line">            return mTheme;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mThemeResource = Resources.selectDefaultTheme(mThemeResource,</div><div class="line">                getApplicationInfo().targetSdkVersion);</div><div class="line">        initializeTheme();</div><div class="line"></div><div class="line">        return mTheme;</div><div class="line">    &#125;</div><div class="line">    //Activity的主题产生作用。覆盖Application的相同属性</div><div class="line">    protected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) &#123;</div><div class="line">        theme.applyStyle(resid, true);</div><div class="line">    &#125;</div><div class="line">    //生成主题并获取Application的主题赋值给新主题，并使Activity的主题产生作用。</div><div class="line">    private void initializeTheme() &#123;</div><div class="line">        final boolean first = mTheme == null;</div><div class="line">        if (first) &#123;</div><div class="line">            mTheme = getResources().newTheme();</div><div class="line">            Resources.Theme theme = mBase.getTheme();</div><div class="line">            if (theme != null) &#123;</div><div class="line">                mTheme.setTo(theme);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //Activity的主题产生作用。</div><div class="line">        onApplyThemeResource(mTheme, mThemeResource, first);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里就已经产生基本的不同了，比如EditText 的字体颜色 设置属性为？textcolor,这时如果Application设置为黑色，而Activity的主题中设置为红色，那么如果这个Activity的某个EditText用了Application，那么这时字体会显示黑色而不是预期的红色。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/09/View-Context-leak/" data-id="civaxo6vh00004ks2y6huor2t" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-内存泄露" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/06/内存泄露/" class="article-date">
  <time datetime="2016-11-06T09:28:32.000Z" itemprop="datePublished">2016-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/内存泄露/">Android内存泄露</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>做过Android的应该知道，如果不关心内存的泄露问题，就会导致内存溢出，那么应用就会出现随时崩溃的问题，用户体验很差，就比如我最早做的一个项目，其中包含考试的模块，一开始也没有做考试备份的功能，也就是放弃考试必须重新考试。有一次测试中，100道题快要做完时，因为有一题包含了图片，所以崩溃了，然后所有的都完蛋了，我自己作为开发者都快崩溃了，更不要说那些认真答题的使用者了。所以为了用户的满意度必须解决内存泄露的问题。因为Android上层使用的是Java，所以大家知道Java的特性就应该知道Android为什么会存在内存泄露了。</p>
<p>##1、static静态变量内存泄露##</p>
<p>问题：<br>有时我们为了方便各个组件之间传递大数据不得不使用static变量，因为static变量是属于类的，所以可以之间使用类调用，还是那个包含考试的项目，因为需要把试题传递到另一个Activity使用，但数据本身太大超过了Intent传递数据的上限。所以使用了静态变量，最后也没有释放，这就产生了泄露，还有就是类似于Activity的静态变量，也是一个很早的项目里面涉及到电话监听，我忘了是监听电话开始还是结束状态，但监听会调用两次，然后会启动两次Activity，这时问题就出来了，当时没什么技术，也没解决问题的理念，所以竟然把Activity当成了静态变量保存在了那个Activity中，具体的我已经忘了，但是我知道最后Activity中的静态对象没有释放，也就是永远会把最后一个实例化的Activity放在静态变量中，没有释放。<br>解决方案：<br>这样做本身没有太大的问题，但如果不释放内存就有问题了，在这中情况下，只需要在不需要的时候释放内存就行了，比如上面两个问题，其实只要在Activity的onDestory方法中设置为null,就把引用释放了。</p>
<p>##2、资源未关闭或未回收导致的内存泄露##<br>问题：<br>数据库Cursor没关闭，IO流没关闭，当使用SQLite数据库没有关闭Cursor，以及文件流没有关闭都会导致内存泄露。<br>解决方案：<br>调用Cursor.close()，以及IO的close方法。</p>
<p>##3、未取消注册广播接收者##<br>问题：<br>使用广播时只注册没有取消注册。<br>解决方案：<br>registerReceiver()和unregisterReceiver()要成对出现，通常需要在Activity的onDestory()方法去取消注册广播接收者。</p>
<p>##4、第三方jar包使用不当导致的内存泄露##<br>问题：<br>使用第三方jar包没有注意使用细节出现，比如eventBus只注册而忘记取消注册，百度地图或高德地图没有调用map的onDestory的方法等等。<br>解决方案：<br>使用第三方是要注意其使用注意事项及时释放引用。当然也有的第三方jar包本身就有问题，不提供释放方法，比如我就遇到过一个gif播放jar包，使用过后肯定会导致泄露，最后只能用反射把引用对象设置为null才把泄露解决，这也就要求我们选择jar包时要经过测试，不能遇到解决方法就用，当然还是我当时水平不行，其实当时应该修改源码再打成jar的。</p>
<p>##5、Context使用不当导致的内存泄露##<br>问题：<br>我以前写了并收集了一些公共方法类，然后在项目中使用而这些方法类中使用了Context，而且只要是Context就可以。当时觉得每次传一个Context参数太麻烦然后写了一个UtilsConfig类。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class UtilsConfig&#123;</div><div class="line">   private static Context mContext;</div><div class="line">   </div><div class="line">   private <span class="function"><span class="title">UtilsConfig</span></span>()&#123;</div><div class="line">      throw new RuntimeException(<span class="string">"UtilsConfig不能实例化"</span>);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public static init(Context mContext)&#123;</div><div class="line">      UtilsConfig.mContext = mContext;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public static Context <span class="function"><span class="title">getContext</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(mContext == null)&#123;</div><div class="line">	     throw new RuntimeException(<span class="string">"UtilsConfig 未初始化"</span>);</div><div class="line">	  &#125;</div><div class="line">	  <span class="built_in">return</span> mContext;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出如果在一个Activity中调用该方法，肯定会产生泄露。<br>解决方案：<br>该方法其实使用的是ApplicationContext,所以只要在Application类中初始化就可以了。当然我们要看到另一个问题，就是如果所需要的参数Application本身就可以那么就不要使用Activity等，因为Application的生命周期是全局的所以不会产生内存泄露。一个原则就是能用Application就用Application，当然我的上一个方法后来也进行了改进。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class UtilsConfig&#123;</div><div class="line">   private static Context mContext;</div><div class="line">   </div><div class="line">   private <span class="function"><span class="title">UtilsConfig</span></span>()&#123;</div><div class="line">      throw new RuntimeException(<span class="string">"UtilsConfig不能实例化"</span>);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public static init(Context mContext)&#123;</div><div class="line">      UtilsConfig.mContext = mContext.getApplicationContext();</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public static Context <span class="function"><span class="title">getContext</span></span>()&#123;</div><div class="line">      <span class="keyword">if</span>(mContext == null)&#123;</div><div class="line">	     throw new RuntimeException(<span class="string">"UtilsConfig 未初始化"</span>);</div><div class="line">	  &#125;</div><div class="line">	  <span class="built_in">return</span> mContext;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##6、Handler导致内存泄露##<br>问题：<br>知道Handler原理的都清楚，Handler模块主要有三个类组成，分别是Handler、Looper以及MessageQueue三部分组成。Handler负责消息处理，Looper主要负责消息循环获取，MessageQueue就是消息队列管理，而每个线程只能有一个Looper以及MessageQueue，可以有多个Handler，而我们使用时基本上是在主线程上使用，也就是说我们是在使用主线程的Looper、MessageQueue。而这个MessageQueue的生命周期是全局的，所以如果对象被MessageQueue持有引用则无法被回收。如果是使用其他线程的Handler，如果那个线程持续运行，而Looper也没停止·，结果是一样的。引用链为<br>MessageQueue 持有 Message ，<br>Message 持有 Handler，<br>Handler 持有 View 或 Activity。<br>从而导致内存泄露。<br>解决方案：<br>如果只是MessageQueue导致的内存泄露。只需要调用。Handler.removeCallbacksAndMessages(null);即可，这会请求MessageQueue中所有该Handler的Message。如果是线程持有该对象，该对象又是内部类导致的泄露放在下面。</p>
<p>##7、内部类或匿名类导致内存泄露##<br>问题：<br>我们知道非静态内部类持有外部类的引用，匿名类同样会持有定义它们的对象的引用。而匿名类或内部类对象又被其他类持有引用导致内存泄露，比如我写了一个天气预报的模块，我直接使用的中国天气网的数据，所以网络请求做了单独写，然后我用匿名类对象做了网络请求回调，然后在请求结束之前退出，网络请求继续，从而Activity也泄露了。<br>解决方案：<br>内部类泄露一般解决方案是该为静态内部类，然后静态内部类持有Activity的弱引用。匿名类也可以先该为静态类，然后再实例化，其他和内部类处理方式一致，其实如果在Activity执行onDestory时把持有内部类或匿名类对被持有引用的地方置为null即可。</p>
<p>##8、异步任务导致内存泄露##<br>问题：<br>这里的异步任务我把线程以及定时器都作为了异步任务。<br>解决方案：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/06/内存泄露/" data-id="civaxmvl30002q8s2k45moav2" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Bundle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/Android-Bundle/" class="article-date">
  <time datetime="2016-11-02T11:03:12.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/Android-Bundle/">Bundle、Parcel解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Bundle、Parcel解析"><a href="#Bundle、Parcel解析" class="headerlink" title="Bundle、Parcel解析"></a>Bundle、Parcel解析</h2><p><strong>Bundle</strong> 被我们经常用来进行启动Activity、service以及传递数据.Bundle支持的数据类型有原始类型以及其封装类，Parcelable 类型、Size类型、SizeF类型以及Serializable类型。</p>
<h3 id="Bundle基本使用"><a href="#Bundle基本使用" class="headerlink" title="Bundle基本使用"></a>Bundle基本使用</h3><h4 id="Intent添加数据"><a href="#Intent添加数据" class="headerlink" title="Intent添加数据"></a>Intent添加数据</h4><p>我们先看一下Bundle的添加传递信息的方法，<br>添加Parcelable类型参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void putParcelable(@Nullable String key, @Nullable Parcelable value) &#123;</div><div class="line">        unparcel();</div><div class="line">        mMap.put(key, value);</div><div class="line">        mFdsKnown = <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>添加float类型参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">    public void putFloat(@Nullable String key, <span class="built_in">float</span> value) &#123;</div><div class="line">        super.putFloat(key, value);</div><div class="line">    &#125;</div><div class="line">//调用父类方法保存参数</div><div class="line">void putFloat(@Nullable String key, <span class="built_in">float</span> value) &#123;</div><div class="line">        unparcel();</div><div class="line">        mMap.put(key, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>通过putParcelable 方法和putFloat 方法可以看出最后数据都会保存在mMap对象中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayMap&lt;String, Object&gt; mMap = null;</div><div class="line">.....</div><div class="line">mMap = capacity &gt; 0 ?</div><div class="line">               new ArrayMap&lt;String, Object&gt;(capacity) : new ArrayMap&lt;String, Object&gt;();</div></pre></td></tr></table></figure></p>
<p>mMap的定义可以看出mMap就是一个ArrayMap，存放键值对，而且value的类型是Object类型，就是所有参数的类型都被转换为Object类型保存在mMap中。而系统如何使用这些数据以下再说。</p>
<h3 id="Bundle数据储存"><a href="#Bundle数据储存" class="headerlink" title="Bundle数据储存"></a>Bundle数据储存</h3><h4 id="找到Intent数据保存的切入点"><a href="#找到Intent数据保存的切入点" class="headerlink" title="找到Intent数据保存的切入点"></a>找到Intent数据保存的切入点</h4><p>通过研究activity的startActivity方法，发现最后会调用ActivityManagerProxy的startActivity方法，该类是ActivityManagerNative的内部类.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">参数重点是intent，就是我放入startActivity的intent</div><div class="line">   public int startActivity(IApplicationThread <span class="built_in">caller</span>, String callingPackage, Intent intent,</div><div class="line">            String resolvedType, IBinder resultTo, String resultWho, int requestCode,</div><div class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeStrongBinder(<span class="built_in">caller</span> != null ? caller.asBinder() : null);</div><div class="line">        data.writeString(callingPackage);</div><div class="line">        //使用该方法把Intent的Bundle的参数导入Parcel的data中，</div><div class="line">        intent.writeToParcel(data, 0);</div><div class="line">        data.writeString(resolvedType);</div><div class="line">        data.writeStrongBinder(resultTo);</div><div class="line">        data.writeString(resultWho);</div><div class="line">        data.writeInt(requestCode);</div><div class="line">        data.writeInt(startFlags);</div><div class="line">        <span class="keyword">if</span> (profilerInfo != null) &#123;</div><div class="line">            data.writeInt(1);</div><div class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            data.writeInt(0);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (options != null) &#123;</div><div class="line">            data.writeInt(1);</div><div class="line">            options.writeToParcel(data, 0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            data.writeInt(0);</div><div class="line">        &#125;</div><div class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</div><div class="line">        reply.readException();</div><div class="line">        int result = reply.readInt();</div><div class="line">        reply.recycle();</div><div class="line">        data.recycle();</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出最后Intent调用了writeToParcel方法，把Bundle中的数据导入进Parcel类型数据中，再看writeToParcel的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void writeToParcel(Parcel out, int flags) &#123;</div><div class="line">       ....</div><div class="line">       省略</div><div class="line">       ....</div><div class="line">       //mExtras就是保持的Bundle类型数据，也就是我们要保存的数据</div><div class="line">       out.writeBundle(mExtras);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>顺着代码调用进入到了Parcel的writeBundle方法，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final void writeBundle(Bundle val) &#123;</div><div class="line">        <span class="keyword">if</span> (val == null) &#123;</div><div class="line">            writeInt(-1);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        //调用需要传递数据的Bundle的writeToParcel方法</div><div class="line">        val.writeToParcel(this, 0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后还是回到Bundle类本身。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//Bundle的方法</div><div class="line">public void writeToParcel(Parcel parcel, int flags) &#123;</div><div class="line">       final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);</div><div class="line">       try &#123;</div><div class="line">           //调用父类的方法写入数据</div><div class="line">           super.writeToParcelInner(parcel, flags);</div><div class="line">       &#125; finally &#123;</div><div class="line">           parcel.restoreAllowFds(oldAllowFds);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   //BaseBundle把本身数据写入parcel中</div><div class="line">   void writeToParcelInner(Parcel parcel, int flags) &#123;</div><div class="line">       <span class="keyword">if</span> (mParcelledData != null) &#123;</div><div class="line">           <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</div><div class="line">               parcel.writeInt(0);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               int length = mParcelledData.dataSize();</div><div class="line">               parcel.writeInt(length);</div><div class="line">               parcel.writeInt(BUNDLE_MAGIC);</div><div class="line">               parcel.appendFrom(mParcelledData, 0, length);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           // Special <span class="keyword">case</span> <span class="keyword">for</span> empty bundles.</div><div class="line">           <span class="keyword">if</span> (mMap == null || mMap.size() &lt;= 0) &#123;</div><div class="line">               parcel.writeInt(0);</div><div class="line">               <span class="built_in">return</span>;</div><div class="line">           &#125;</div><div class="line">           int lengthPos = parcel.dataPosition();</div><div class="line">           parcel.writeInt(-1); // dummy, will hold length</div><div class="line">           parcel.writeInt(BUNDLE_MAGIC);</div><div class="line"></div><div class="line">           int startPos = parcel.dataPosition();</div><div class="line">           //核心代码，mMap就是上面一开始保存数据的对象，也就是所有需要传输的数据都在该对象中。又返回到了Parcel的方法中</div><div class="line">           parcel.writeArrayMapInternal(mMap);</div><div class="line">           int endPos = parcel.dataPosition();</div><div class="line"></div><div class="line">           // Backpatch length</div><div class="line">           parcel.setDataPosition(lengthPos);</div><div class="line">           int length = endPos - startPos;</div><div class="line">           parcel.writeInt(length);</div><div class="line">           parcel.setDataPosition(endPos);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>Parcel最后都都调用write方法保存，最后都会调用本地方法，因为Parcel的数据结构都在c层，所以不做深入研究。有兴趣的可以看看，路径为frameworks\base\core\jni\android_os_Parcel.cpp,以及frameworks\native\libs\binder\Parcel.cpp。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void writeArrayMapInternal(ArrayMap&lt;String, Object&gt; val) &#123;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">        int startPos;</div><div class="line">        <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) startPos = dataPosition();</div><div class="line">            // 写入mMap的key值</div><div class="line">            writeString(val.keyAt(i));</div><div class="line">            // 写入mMap的value值</div><div class="line">            writeValue(val.valueAt(i));</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) Log.d(TAG, <span class="string">"  Write #"</span> + i + <span class="string">" "</span></div><div class="line">                    + (dataPosition()-startPos) + <span class="string">" bytes: key=0x"</span></div><div class="line">                    + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)</div><div class="line">                    + <span class="string">" "</span> + val.keyAt(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走到这里，基本可以理清mMap的数据最后都会写入Parcel中，也就是说Bundle也是使用Parcel传递的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">public final void writeValue(Object v) &#123;</div><div class="line">    <span class="keyword">if</span> (v == null) &#123;</div><div class="line">        writeInt(VAL_NULL);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof String) &#123;</div><div class="line">        writeInt(VAL_STRING);</div><div class="line">        writeString((String) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Integer) &#123;</div><div class="line">        writeInt(VAL_INTEGER);</div><div class="line">        writeInt((Integer) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Map) &#123;</div><div class="line">        writeInt(VAL_MAP);</div><div class="line">        writeMap((Map) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Bundle) &#123;</div><div class="line">        // Must be before Parcelable</div><div class="line">        writeInt(VAL_BUNDLE);</div><div class="line">        writeBundle((Bundle) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Parcelable) &#123;</div><div class="line">        writeInt(VAL_PARCELABLE);</div><div class="line">        writeParcelable((Parcelable) v, 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Short) &#123;</div><div class="line">        writeInt(VAL_SHORT);</div><div class="line">        writeInt(((Short) v).intValue());</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Long) &#123;</div><div class="line">        writeInt(VAL_LONG);</div><div class="line">        writeLong((Long) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Float) &#123;</div><div class="line">        writeInt(VAL_FLOAT);</div><div class="line">        writeFloat((Float) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Double) &#123;</div><div class="line">        writeInt(VAL_DOUBLE);</div><div class="line">        writeDouble((Double) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Boolean) &#123;</div><div class="line">        writeInt(VAL_BOOLEAN);</div><div class="line">        writeInt((Boolean) v ? 1 : 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof CharSequence) &#123;</div><div class="line">        // Must be after String</div><div class="line">        writeInt(VAL_CHARSEQUENCE);</div><div class="line">        writeCharSequence((CharSequence) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof List) &#123;</div><div class="line">        writeInt(VAL_LIST);</div><div class="line">        writeList((List) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof SparseArray) &#123;</div><div class="line">        writeInt(VAL_SPARSEARRAY);</div><div class="line">        writeSparseArray((SparseArray) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof boolean[]) &#123;</div><div class="line">        writeInt(VAL_BOOLEANARRAY);</div><div class="line">        writeBooleanArray((boolean[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof byte[]) &#123;</div><div class="line">        writeInt(VAL_BYTEARRAY);</div><div class="line">        writeByteArray((byte[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof String[]) &#123;</div><div class="line">        writeInt(VAL_STRINGARRAY);</div><div class="line">        writeStringArray((String[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof CharSequence[]) &#123;</div><div class="line">        // Must be after String[] and before Object[]</div><div class="line">        writeInt(VAL_CHARSEQUENCEARRAY);</div><div class="line">        writeCharSequenceArray((CharSequence[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof IBinder) &#123;</div><div class="line">        writeInt(VAL_IBINDER);</div><div class="line">        writeStrongBinder((IBinder) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Parcelable[]) &#123;</div><div class="line">        writeInt(VAL_PARCELABLEARRAY);</div><div class="line">        writeParcelableArray((Parcelable[]) v, 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof int[]) &#123;</div><div class="line">        writeInt(VAL_INTARRAY);</div><div class="line">        writeIntArray((int[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof long[]) &#123;</div><div class="line">        writeInt(VAL_LONGARRAY);</div><div class="line">        writeLongArray((long[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Byte) &#123;</div><div class="line">        writeInt(VAL_BYTE);</div><div class="line">        writeInt((Byte) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof PersistableBundle) &#123;</div><div class="line">        writeInt(VAL_PERSISTABLEBUNDLE);</div><div class="line">        writePersistableBundle((PersistableBundle) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Size) &#123;</div><div class="line">        writeInt(VAL_SIZE);</div><div class="line">        writeSize((Size) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof SizeF) &#123;</div><div class="line">        writeInt(VAL_SIZEF);</div><div class="line">        writeSizeF((SizeF) v);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Class&lt;?&gt; clazz = v.getClass();</div><div class="line">        <span class="keyword">if</span> (clazz.isArray() &amp;&amp; clazz.getComponentType() == Object.class) &#123;</div><div class="line">            // Only pure Object[] are written here, Other arrays of non-primitive types are</div><div class="line">            // handled by serialization as this does not record the component type.</div><div class="line">            writeInt(VAL_OBJECTARRAY);</div><div class="line">            writeArray((Object[]) v);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Serializable) &#123;</div><div class="line">            // Must be last</div><div class="line">            writeInt(VAL_SERIALIZABLE);</div><div class="line">            writeSerializable((Serializable) v);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            throw new RuntimeException(<span class="string">"Parcel: unable to marshal value "</span> + v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要写入Parcel的对象要先判断类型，然后先写入该对象的类型标志，再调用对应类型的方法写入要保存数据。这里需要关注的只有一点，就是Map类型的对象保存，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final void writeMap(Map val) &#123;</div><div class="line">       writeMapInternal((Map&lt;String, Object&gt;) val);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> void writeMapInternal(Map&lt;String,Object&gt; val) &#123;</div><div class="line">       <span class="keyword">if</span> (val == null) &#123;</div><div class="line">           writeInt(-1);</div><div class="line">           <span class="built_in">return</span>;</div><div class="line">       &#125;</div><div class="line">       Set&lt;Map.Entry&lt;String,Object&gt;&gt; entries = val.entrySet();</div><div class="line">       writeInt(entries.size());</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; e : entries) &#123;</div><div class="line">           writeValue(e.getKey());</div><div class="line">           writeValue(e.getValue());</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>Parcel只是获取Map的键值对，然后保存，该方法没有保存Map类的信息，也就是类型擦除，最后经过startActivity跳到其他Activity时，再获取时所以Map类型对象都会转换为HashMap对象，所以Bundle传递数据不能使用其他Map类型，比如TreeMap。</p>
<h3 id="Parcel转换为类型对象"><a href="#Parcel转换为类型对象" class="headerlink" title="Parcel转换为类型对象"></a>Parcel转换为类型对象</h3><p>这里还是从Intent类看起，Intent实现了Parcelable，ActivityManagerProxy的startActivity方法中intent.writeToParcel(data, 0);通过这个方法Intent把对象的具体信息写入Parcel中，通过一连串的传输最后又通过序列化转为Intent对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">protected Intent(Parcel <span class="keyword">in</span>) &#123;</div><div class="line">        <span class="built_in">read</span>FromParcel(<span class="keyword">in</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void <span class="built_in">read</span>FromParcel(Parcel <span class="keyword">in</span>) &#123;</div><div class="line">        //恢复action属性</div><div class="line">        <span class="built_in">set</span>Action(in.readString());</div><div class="line">        //恢复Data属性</div><div class="line">        mData = Uri.CREATOR.createFromParcel(<span class="keyword">in</span>);</div><div class="line">        //Type属性</div><div class="line">        mType = in.readString();</div><div class="line">        //Flag属性,启动模式</div><div class="line">        mFlags = in.readInt();</div><div class="line">        mPackage = in.readString();</div><div class="line">        mComponent = ComponentName.readFromParcel(<span class="keyword">in</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mSourceBounds = Rect.CREATOR.createFromParcel(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int N = in.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt; 0) &#123;</div><div class="line">            mCategories = new ArraySet&lt;String&gt;();</div><div class="line">            int i;</div><div class="line">            <span class="keyword">for</span> (i=0; i&lt;N; i++) &#123;</div><div class="line">                mCategories.add(in.readString().intern());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mCategories = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mSelector = new Intent(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mClipData = new ClipData(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line">        mContentUserHint = in.readInt();</div><div class="line">        //传递的数据</div><div class="line">        mExtras = in.readBundle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>使用过Parcelable的都知道反序列化最后都会调用包含Parcel参数的构造函数，对于Intent就是Intent(Parcel in)，然后调用readFromParcel方法，把Intent的相关属性恢复。对于Bundle数据的恢复是调用了Parcel的readBundle方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">//Parcel.java </div><div class="line">public final Bundle <span class="function"><span class="title">readBundle</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">read</span>Bundle(null);</div><div class="line">&#125;</div><div class="line">//Parcel.java </div><div class="line">public final Bundle <span class="built_in">read</span>Bundle(ClassLoader loader) &#123;</div><div class="line">    //获取Bundle保存数据的长度</div><div class="line">    int length = <span class="built_in">read</span>Int();</div><div class="line">    <span class="keyword">if</span> (length &lt; 0) &#123;</div><div class="line">        <span class="keyword">if</span> (Bundle.DEBUG) Log.d(TAG, <span class="string">"null bundle: length="</span> + length);</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    final Bundle bundle = new Bundle(this, length);</div><div class="line">    <span class="keyword">if</span> (loader != null) &#123;</div><div class="line">        bundle.setClassLoader(loader);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> bundle;</div><div class="line">&#125;</div><div class="line">//Bundle.java</div><div class="line">Bundle(Parcel parcelledData, int length) &#123;</div><div class="line">    super(parcelledData, length);</div><div class="line"></div><div class="line">    mHasFds = mParcelledData.hasFileDescriptors();</div><div class="line">    mFdsKnown = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">//BaseBundle.java</div><div class="line">BaseBundle(Parcel parcelledData, int length) &#123;</div><div class="line">    <span class="built_in">read</span>FromParcelInner(parcelledData, length);</div><div class="line">&#125;</div><div class="line">//BaseBundle.java</div><div class="line">private void <span class="built_in">read</span>FromParcelInner(Parcel parcel, int length) &#123;</div><div class="line">    <span class="keyword">if</span> (length == 0) &#123;</div><div class="line">        // Empty Bundle or end of data.</div><div class="line">        mParcelledData = EMPTY_PARCEL;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    //获取数据类型魔数，若不为BUNDLE_MAGIC，则抛出异常。</div><div class="line">    int magic = parcel.readInt();</div><div class="line">    <span class="keyword">if</span> (magic != BUNDLE_MAGIC) &#123;</div><div class="line">        //noinspection ThrowableInstanceNeverThrown</div><div class="line">        throw new IllegalStateException(<span class="string">"Bad magic number for Bundle: 0x"</span></div><div class="line">                + Integer.toHexString(magic));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Advance within this Parcel</div><div class="line">    int offset = parcel.dataPosition();</div><div class="line">    parcel.setDataPosition(offset + length);</div><div class="line"></div><div class="line">    Parcel p = Parcel.obtain();</div><div class="line">    p.setDataPosition(0);</div><div class="line">    //通过传入的Parcel对象生成一个新的Parcel对象，也就是截取Parcel的数据组成新的Parcel对象。</div><div class="line">    p.appendFrom(parcel, offset, length);</div><div class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Retrieving "</span>  + Integer.toHexString(System.identityHashCode(this))</div><div class="line">            + <span class="string">": "</span> + length + <span class="string">" bundle bytes starting at "</span> + offset);</div><div class="line">    p.setDataPosition(0);</div><div class="line">    //然后把新生成的Parcel赋值给Bundle。</div><div class="line">    mParcelledData = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Intent的readBundle方法没有直接的把Parcel数据解析为对象数据，还是以Parcel形式保存着，那Parcel是什么时候解析的呢？然后我查看了一下Bundle的get方法，发现最后都调用了unparcel()。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public byte getByte(String key) &#123;</div><div class="line">    <span class="built_in">return</span> super.getByte(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">byte getByte(String key) &#123;</div><div class="line">    unparcel();</div><div class="line">    <span class="built_in">return</span> getByte(key, (byte) 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就开始研究unparcel()方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">synchronized void <span class="function"><span class="title">unparcel</span></span>() &#123;</div><div class="line">      //没有Parcel数据，不创建mMap对象，直接返回</div><div class="line">      <span class="keyword">if</span> (mParcelledData == null) &#123;</div><div class="line">          <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">                  + <span class="string">": no parcelled data"</span>);</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      //mParcelledData为默认的EMPTY_PARCEL，创建或清理mMap对象，不解析数据，直接返回</div><div class="line">      <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</div><div class="line">          <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">                  + <span class="string">": empty"</span>);</div><div class="line">          <span class="keyword">if</span> (mMap == null) &#123;</div><div class="line">              mMap = new ArrayMap&lt;String, Object&gt;(1);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              mMap.erase();</div><div class="line">          &#125;</div><div class="line">          mParcelledData = null;</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      //解析Parcel数据，或取Parcel含有多少键值对数据</div><div class="line">      int N = mParcelledData.readInt();</div><div class="line">      <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">              + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</div><div class="line">      <span class="keyword">if</span> (N &lt; 0) &#123;</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (mMap == null) &#123;</div><div class="line">          mMap = new ArrayMap&lt;String, Object&gt;(N);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          mMap.erase();</div><div class="line">          mMap.ensureCapacity(N);</div><div class="line">      &#125;</div><div class="line">      //核心功能读取数据放入mMap中</div><div class="line">      mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</div><div class="line">      mParcelledData.recycle();</div><div class="line">      mParcelledData = null;</div><div class="line">      <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">              + <span class="string">" final map: "</span> + mMap);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>unparcel方法的就是判断当前的Bundle是否含有Parcel数据，然后根据结果创建mMap对象，然后调用readArrayMapInternal把Parcel中的数据发序列化为对象。然后存放在mMap中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void <span class="built_in">read</span>ArrayMapInternal(ArrayMap outVal, int N,</div><div class="line">        ClassLoader loader) &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG_ARRAY_MAP) &#123;</div><div class="line">            RuntimeException here =  new RuntimeException(<span class="string">"here"</span>);</div><div class="line">            here.fillInStackTrace();</div><div class="line">            Log.d(TAG, <span class="string">"Reading "</span> + N + <span class="string">" ArrayMap entries"</span>, here);</div><div class="line">        &#125;</div><div class="line">        int startPos;</div><div class="line">        <span class="keyword">while</span> (N &gt; 0) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) startPos = dataPosition();</div><div class="line">            String key = <span class="built_in">read</span>String();</div><div class="line">            Object value = <span class="built_in">read</span>Value(loader);</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) Log.d(TAG, <span class="string">"  Read #"</span> + (N-1) + <span class="string">" "</span></div><div class="line">                    + (dataPosition()-startPos) + <span class="string">" bytes: key=0x"</span></div><div class="line">                    + Integer.toHexString((key != null ? key.hashCode() : 0)) + <span class="string">" "</span> + key);</div><div class="line">            outVal.append(key, value);</div><div class="line">            N--;</div><div class="line">        &#125;</div><div class="line">        outVal.validate();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到先读取了key，然后调用readValue获取value的值，然后存储到mMap中。我在这里主要分析一下Map类型数据的获取，可以很明了的知道为什么强制为TreeMap会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> public final Object <span class="built_in">read</span>Value(ClassLoader loader) &#123;</div><div class="line">     int <span class="built_in">type</span> = <span class="built_in">read</span>Int();</div><div class="line"></div><div class="line">     switch (<span class="built_in">type</span>) &#123;</div><div class="line">     <span class="keyword">case</span> VAL_NULL:</div><div class="line">         <span class="built_in">return</span> null;</div><div class="line">     ...</div><div class="line">     省略</div><div class="line">     ...</div><div class="line">     <span class="keyword">case</span> VAL_MAP:</div><div class="line">         <span class="built_in">return</span> <span class="built_in">read</span>HashMap(loader);</div><div class="line">     ...</div><div class="line">     省略</div><div class="line">     ...</div><div class="line">     </div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public final HashMap <span class="built_in">read</span>HashMap(ClassLoader loader)</div><div class="line"> &#123;</div><div class="line">     int N = <span class="built_in">read</span>Int();</div><div class="line">     <span class="keyword">if</span> (N &lt; 0) &#123;</div><div class="line">         <span class="built_in">return</span> null;</div><div class="line">     &#125;</div><div class="line">     HashMap m = new HashMap(N);</div><div class="line">     <span class="built_in">read</span>MapInternal(m, N, loader);</div><div class="line">     <span class="built_in">return</span> m;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>一切都很明了，Parcel对Map类型的数据进行反序列化时，获取key\value的值都存放在HashMap中，然后返回HashMap，也就是说所有Map类型数据最后都会转为HashMap类型数据。强制当然会报错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/02/Android-Bundle/" data-id="civaxmvkt0001q8s28auwqmfm" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/31/hello-world/" class="article-date">
  <time datetime="2016-10-31T14:34:40.809Z" itemprop="datePublished">2016-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/31/hello-world/">Java 动态代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>动态代理第一次遇到是研究<a href="https://github.com/square/retrofit/" target="_blank" rel="external">Retrofit</a>源码时,经过代码分析发现retrofit巧妙的运用了动态代理把请求接口类的方法的注解信息以及参数按照既定的规则组合成完整的请求。</p>
<h2 id="动态代理的简单用例"><a href="#动态代理的简单用例" class="headerlink" title="动态代理的简单用例"></a>动态代理的简单用例</h2><h3 id="一个简单的接口类"><a href="#一个简单的接口类" class="headerlink" title="一个简单的接口类"></a>一个简单的接口类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Person &#123;	</div><div class="line">   void <span class="keyword">do</span>This(String thing);</div><div class="line">   void <span class="keyword">do</span>That(String thing);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出该类只有一个简单的方法，</p>
<h3 id="InvocationHandler-类的编写"><a href="#InvocationHandler-类的编写" class="headerlink" title="InvocationHandler 类的编写"></a>InvocationHandler 类的编写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class PersonInvocationHandler implements InvocationHandler &#123;</div><div class="line"></div><div class="line">	public Object invoke(Object proxy, Method method, Object[] args)&#123;</div><div class="line">	  <span class="keyword">if</span>(method.getName().equals(<span class="string">"doThis"</span>))&#123;</div><div class="line">         System.out.println(args[0]);</div><div class="line">         <span class="built_in">return</span> null;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(method.getName().equals(<span class="string">"doThat"</span>))&#123;</div><div class="line">          System.out.println(args[0]);</div><div class="line">          <span class="built_in">return</span> null;</div><div class="line">       &#125;</div><div class="line">      <span class="built_in">return</span> null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Person person = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class[]&#123;Person.class&#125;, new PersonInvocationHandler());</div><div class="line">		person.doThis(<span class="string">"I do this thing"</span>);</div><div class="line">		person.doThat(<span class="string">"I do that thing"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I <span class="keyword">do</span> this thing</div><div class="line">I <span class="keyword">do</span> that thing</div></pre></td></tr></table></figure></p>
<p>通过输出接口分析，动态代理生成的对象调用方法时最终都会调用InvocationHandler的invoke方法，invoke(Object proxy, Method method, Object[] args) 可以看出 proxy是代理对象本身，method是调用的方法属性，而args数组就是方法参数。</p>
<h2 id="动态代理的源码解析"><a href="#动态代理的源码解析" class="headerlink" title="动态代理的源码解析"></a>动态代理的源码解析</h2><p>我就从对象生成这句代码看起：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person person = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class[]&#123;Person.class&#125;, new PersonInvocationHandler());</div></pre></td></tr></table></figure>
<p>从而找到实现代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,</div><div class="line">                                          InvocationHandler invocationHandler)</div><div class="line">            throws IllegalArgumentException &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (invocationHandler == null) &#123;</div><div class="line">            throw new NullPointerException(<span class="string">"invocationHandler == null"</span>);</div><div class="line">        &#125;</div><div class="line">        Exception cause;</div><div class="line">        try &#123;</div><div class="line">            <span class="built_in">return</span> getProxyClass(loader, interfaces)</div><div class="line">                    .getConstructor(InvocationHandler.class)</div><div class="line">                    .newInstance(invocationHandler);</div><div class="line">        &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">            cause = e;</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            cause = e;</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            cause = e;</div><div class="line">        &#125; catch (InvocationTargetException e) &#123;</div><div class="line">            cause = e;</div><div class="line">        &#125;</div><div class="line">        AssertionError error = new AssertionError();</div><div class="line">        error.initCause(cause);</div><div class="line">        throw error;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出该方法主要是对异常情况进行处理，没有涉及到动态代码的原理。可以看出主要实现是getProxyClass方法，getProxyClass作用是获取代理类Class对象。getConstructor方法属于Class的方法，作用是获取构造函数，而newInstance的作用只是为了实例化一个代理类对象。以下查看getProxyClass方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">//从interfaces可以看出，动态代理可以同时实现多个接口</div><div class="line">public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)</div><div class="line">          throws IllegalArgumentException &#123;</div><div class="line">    </div><div class="line">     <span class="keyword">if</span> (loader == null) &#123;</div><div class="line">          loader = ClassLoader.getSystemClassLoader();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (interfaces == null) &#123;</div><div class="line">           throw new NullPointerException(<span class="string">"interfaces == null"</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     final List&lt;Class&lt;?&gt;&gt; interfaceList = new ArrayList&lt;Class&lt;?&gt;&gt;(interfaces.length);</div><div class="line">     Collections.addAll(interfaceList, interfaces);</div><div class="line">     </div><div class="line">     final Set&lt;Class&lt;?&gt;&gt; interfaceSet = new HashSet&lt;Class&lt;?&gt;&gt;(interfaceList);</div><div class="line">     <span class="keyword">if</span> (interfaceSet.contains(null)) &#123;</div><div class="line">         throw new NullPointerException(<span class="string">"interface list contains null: "</span> + interfaceList);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (interfaceSet.size() != interfaces.length) &#123;</div><div class="line">         throw new IllegalArgumentException(<span class="string">"duplicate interface in list: "</span> + interfaceList);</div><div class="line">     &#125;</div><div class="line">     //查看缓存中是否已经存在代理类</div><div class="line">     synchronized (loader.proxyCache) &#123;</div><div class="line">         Class&lt;?&gt; proxy = loader.proxyCache.get(interfaceList);</div><div class="line">         <span class="keyword">if</span> (proxy != null) &#123;</div><div class="line">             <span class="built_in">return</span> proxy;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     String commonPackageName = null;</div><div class="line">     <span class="keyword">for</span> (Class&lt;?&gt; c : interfaces) &#123;</div><div class="line">         //被代理类必须是接口类，这点感觉不好，如果任何类都可以代理那就很爽了</div><div class="line">         <span class="keyword">if</span> (!c.isInterface()) &#123;</div><div class="line">             throw new IllegalArgumentException(c + <span class="string">" is not an interface"</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (!isVisibleToClassLoader(loader, c)) &#123;</div><div class="line">             throw new IllegalArgumentException(c + <span class="string">" is not visible from class loader"</span>);</div><div class="line">         &#125;，</div><div class="line">         <span class="keyword">if</span> (!Modifier.isPublic(c.getModifiers())) &#123;</div><div class="line">             String packageName = c.getPackageName$();</div><div class="line">             <span class="keyword">if</span> (packageName == null) &#123;</div><div class="line">                 packageName = <span class="string">""</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (commonPackageName != null &amp;&amp; !commonPackageName.equals(packageName)) &#123;</div><div class="line">                 throw new IllegalArgumentException(</div><div class="line">                           <span class="string">"non-public interfaces must be in the same package"</span>);</div><div class="line">             &#125;</div><div class="line">             commonPackageName = packageName;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     //可以看出改代码是获取所有接口的方法属性</div><div class="line">     List&lt;Method&gt; methods = getMethods(interfaces);</div><div class="line">     Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE);</div><div class="line">     validateReturnTypes(methods);</div><div class="line">     List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods);</div><div class="line">     Method[] methodsArray = methods.toArray(new Method[methods.size()]);</div><div class="line">     Class&lt;?&gt;[][] exceptionsArray = exceptions.toArray(new Class&lt;?&gt;[exceptions.size()][]);</div><div class="line">     //生成代理类的包名</div><div class="line">     String baseName = commonPackageName != null &amp;&amp; !commonPackageName.isEmpty()</div><div class="line">              ? commonPackageName + <span class="string">".<span class="variable">$Proxy</span>"</span></div><div class="line">              : <span class="string">"<span class="variable">$Proxy</span>"</span>;</div><div class="line"></div><div class="line">     Class&lt;?&gt; result;</div><div class="line">     synchronized (loader.proxyCache) &#123;</div><div class="line">         result = loader.proxyCache.get(interfaceList);</div><div class="line">         <span class="keyword">if</span> (result == null) &#123;</div><div class="line">             String name = baseName + nextClassNameIndex++;</div><div class="line">             //生成Class文件并生成代理类Class对象。</div><div class="line">             result = generateProxy(name, interfaces, loader, methodsArray, exceptionsArray);</div><div class="line">             loader.proxyCache.put(interfaceList, result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static native Class&lt;?&gt; generateProxy(String name, Class&lt;?&gt;[] interfaces,</div><div class="line">                                                ClassLoader loader, Method[] methods,</div><div class="line">                                                Class&lt;?&gt;[][] exceptions);</div></pre></td></tr></table></figure>
<p>从以上代码可以看出动态代理最后的核心就是generateProxy，但它是本地方法，而且涉及动态产生Class文件，暂时不去涉猎，但基本已经搞清了动态代理的基本流程，如下;</p>
<p>1、调用 Proxy 的newProxyInstance 方法传入加载器ClassLoader对象，需要被代理的接口类的Class对象，以及InvocationHandler 的实例。<br>2、调用getProxyClass方法生成代理类Class文件，并加载生成Class对象，并返回。<br>3、然后通过Class对象进行实例化，产生代理类对象。<br>4、当调用代理类实例化对象之后，动态类对象就会回调InvocationHandler的invoke方法，并将方法属性、代理类对象已经参数传人，我们就可以在invoke方法中做统一处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/31/hello-world/" data-id="civaxmvjm0000q8s2yjutoh1o" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/09/View-Context-leak/">Android 输入法导致内存泄露以及WebView内存泄露解决方案</a>
          </li>
        
          <li>
            <a href="/2016/11/06/内存泄露/">Android内存泄露</a>
          </li>
        
          <li>
            <a href="/2016/11/02/Android-Bundle/">Bundle、Parcel解析</a>
          </li>
        
          <li>
            <a href="/2016/10/31/hello-world/">Java 动态代理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>