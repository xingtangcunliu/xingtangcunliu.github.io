<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Bundle、Parcel解析 | xingtangcunliu个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Bundle、Parcel解析Bundle 被我们经常用来进行启动Activity、service以及传递数据.Bundle支持的数据类型有原始类型以及其封装类，Parcelable 类型、Size类型、SizeF类型以及Serializable类型。
Bundle基本使用Intent添加数据我们先看一下Bundle的添加传递信息的方法，添加Parcelable类型参数。12345public v">
<meta property="og:type" content="article">
<meta property="og:title" content="Bundle、Parcel解析">
<meta property="og:url" content="http://yoursite.com/2016/11/02/Android-Bundle/index.html">
<meta property="og:site_name" content="xingtangcunliu个人博客">
<meta property="og:description" content="Bundle、Parcel解析Bundle 被我们经常用来进行启动Activity、service以及传递数据.Bundle支持的数据类型有原始类型以及其封装类，Parcelable 类型、Size类型、SizeF类型以及Serializable类型。
Bundle基本使用Intent添加数据我们先看一下Bundle的添加传递信息的方法，添加Parcelable类型参数。12345public v">
<meta property="og:updated_time" content="2016-11-08T16:27:26.785Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bundle、Parcel解析">
<meta name="twitter:description" content="Bundle、Parcel解析Bundle 被我们经常用来进行启动Activity、service以及传递数据.Bundle支持的数据类型有原始类型以及其封装类，Parcelable 类型、Size类型、SizeF类型以及Serializable类型。
Bundle基本使用Intent添加数据我们先看一下Bundle的添加传递信息的方法，添加Parcelable类型参数。12345public v">
  
    <link rel="alternate" href="/atom.xml" title="xingtangcunliu个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xingtangcunliu个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-Bundle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/Android-Bundle/" class="article-date">
  <time datetime="2016-11-02T11:03:12.000Z" itemprop="datePublished">2016-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Bundle、Parcel解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Bundle、Parcel解析"><a href="#Bundle、Parcel解析" class="headerlink" title="Bundle、Parcel解析"></a>Bundle、Parcel解析</h2><p><strong>Bundle</strong> 被我们经常用来进行启动Activity、service以及传递数据.Bundle支持的数据类型有原始类型以及其封装类，Parcelable 类型、Size类型、SizeF类型以及Serializable类型。</p>
<h3 id="Bundle基本使用"><a href="#Bundle基本使用" class="headerlink" title="Bundle基本使用"></a>Bundle基本使用</h3><h4 id="Intent添加数据"><a href="#Intent添加数据" class="headerlink" title="Intent添加数据"></a>Intent添加数据</h4><p>我们先看一下Bundle的添加传递信息的方法，<br>添加Parcelable类型参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void putParcelable(@Nullable String key, @Nullable Parcelable value) &#123;</div><div class="line">        unparcel();</div><div class="line">        mMap.put(key, value);</div><div class="line">        mFdsKnown = <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>添加float类型参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">    public void putFloat(@Nullable String key, <span class="built_in">float</span> value) &#123;</div><div class="line">        super.putFloat(key, value);</div><div class="line">    &#125;</div><div class="line">//调用父类方法保存参数</div><div class="line">void putFloat(@Nullable String key, <span class="built_in">float</span> value) &#123;</div><div class="line">        unparcel();</div><div class="line">        mMap.put(key, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>通过putParcelable 方法和putFloat 方法可以看出最后数据都会保存在mMap对象中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayMap&lt;String, Object&gt; mMap = null;</div><div class="line">.....</div><div class="line">mMap = capacity &gt; 0 ?</div><div class="line">               new ArrayMap&lt;String, Object&gt;(capacity) : new ArrayMap&lt;String, Object&gt;();</div></pre></td></tr></table></figure></p>
<p>mMap的定义可以看出mMap就是一个ArrayMap，存放键值对，而且value的类型是Object类型，就是所有参数的类型都被转换为Object类型保存在mMap中。而系统如何使用这些数据以下再说。</p>
<h3 id="Bundle数据储存"><a href="#Bundle数据储存" class="headerlink" title="Bundle数据储存"></a>Bundle数据储存</h3><h4 id="找到Intent数据保存的切入点"><a href="#找到Intent数据保存的切入点" class="headerlink" title="找到Intent数据保存的切入点"></a>找到Intent数据保存的切入点</h4><p>通过研究activity的startActivity方法，发现最后会调用ActivityManagerProxy的startActivity方法，该类是ActivityManagerNative的内部类.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">参数重点是intent，就是我放入startActivity的intent</div><div class="line">   public int startActivity(IApplicationThread <span class="built_in">caller</span>, String callingPackage, Intent intent,</div><div class="line">            String resolvedType, IBinder resultTo, String resultWho, int requestCode,</div><div class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeStrongBinder(<span class="built_in">caller</span> != null ? caller.asBinder() : null);</div><div class="line">        data.writeString(callingPackage);</div><div class="line">        //使用该方法把Intent的Bundle的参数导入Parcel的data中，</div><div class="line">        intent.writeToParcel(data, 0);</div><div class="line">        data.writeString(resolvedType);</div><div class="line">        data.writeStrongBinder(resultTo);</div><div class="line">        data.writeString(resultWho);</div><div class="line">        data.writeInt(requestCode);</div><div class="line">        data.writeInt(startFlags);</div><div class="line">        <span class="keyword">if</span> (profilerInfo != null) &#123;</div><div class="line">            data.writeInt(1);</div><div class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            data.writeInt(0);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (options != null) &#123;</div><div class="line">            data.writeInt(1);</div><div class="line">            options.writeToParcel(data, 0);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            data.writeInt(0);</div><div class="line">        &#125;</div><div class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</div><div class="line">        reply.readException();</div><div class="line">        int result = reply.readInt();</div><div class="line">        reply.recycle();</div><div class="line">        data.recycle();</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出最后Intent调用了writeToParcel方法，把Bundle中的数据导入进Parcel类型数据中，再看writeToParcel的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void writeToParcel(Parcel out, int flags) &#123;</div><div class="line">       ....</div><div class="line">       省略</div><div class="line">       ....</div><div class="line">       //mExtras就是保持的Bundle类型数据，也就是我们要保存的数据</div><div class="line">       out.writeBundle(mExtras);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>顺着代码调用进入到了Parcel的writeBundle方法，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final void writeBundle(Bundle val) &#123;</div><div class="line">        <span class="keyword">if</span> (val == null) &#123;</div><div class="line">            writeInt(-1);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        //调用需要传递数据的Bundle的writeToParcel方法</div><div class="line">        val.writeToParcel(this, 0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最后还是回到Bundle类本身。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//Bundle的方法</div><div class="line">public void writeToParcel(Parcel parcel, int flags) &#123;</div><div class="line">       final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);</div><div class="line">       try &#123;</div><div class="line">           //调用父类的方法写入数据</div><div class="line">           super.writeToParcelInner(parcel, flags);</div><div class="line">       &#125; finally &#123;</div><div class="line">           parcel.restoreAllowFds(oldAllowFds);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   //BaseBundle把本身数据写入parcel中</div><div class="line">   void writeToParcelInner(Parcel parcel, int flags) &#123;</div><div class="line">       <span class="keyword">if</span> (mParcelledData != null) &#123;</div><div class="line">           <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</div><div class="line">               parcel.writeInt(0);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               int length = mParcelledData.dataSize();</div><div class="line">               parcel.writeInt(length);</div><div class="line">               parcel.writeInt(BUNDLE_MAGIC);</div><div class="line">               parcel.appendFrom(mParcelledData, 0, length);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           // Special <span class="keyword">case</span> <span class="keyword">for</span> empty bundles.</div><div class="line">           <span class="keyword">if</span> (mMap == null || mMap.size() &lt;= 0) &#123;</div><div class="line">               parcel.writeInt(0);</div><div class="line">               <span class="built_in">return</span>;</div><div class="line">           &#125;</div><div class="line">           int lengthPos = parcel.dataPosition();</div><div class="line">           parcel.writeInt(-1); // dummy, will hold length</div><div class="line">           parcel.writeInt(BUNDLE_MAGIC);</div><div class="line"></div><div class="line">           int startPos = parcel.dataPosition();</div><div class="line">           //核心代码，mMap就是上面一开始保存数据的对象，也就是所有需要传输的数据都在该对象中。又返回到了Parcel的方法中</div><div class="line">           parcel.writeArrayMapInternal(mMap);</div><div class="line">           int endPos = parcel.dataPosition();</div><div class="line"></div><div class="line">           // Backpatch length</div><div class="line">           parcel.setDataPosition(lengthPos);</div><div class="line">           int length = endPos - startPos;</div><div class="line">           parcel.writeInt(length);</div><div class="line">           parcel.setDataPosition(endPos);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>Parcel最后都都调用write方法保存，最后都会调用本地方法，因为Parcel的数据结构都在c层，所以不做深入研究。有兴趣的可以看看，路径为frameworks\base\core\jni\android_os_Parcel.cpp,以及frameworks\native\libs\binder\Parcel.cpp。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void writeArrayMapInternal(ArrayMap&lt;String, Object&gt; val) &#123;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">        int startPos;</div><div class="line">        <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) startPos = dataPosition();</div><div class="line">            // 写入mMap的key值</div><div class="line">            writeString(val.keyAt(i));</div><div class="line">            // 写入mMap的value值</div><div class="line">            writeValue(val.valueAt(i));</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) Log.d(TAG, <span class="string">"  Write #"</span> + i + <span class="string">" "</span></div><div class="line">                    + (dataPosition()-startPos) + <span class="string">" bytes: key=0x"</span></div><div class="line">                    + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)</div><div class="line">                    + <span class="string">" "</span> + val.keyAt(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走到这里，基本可以理清mMap的数据最后都会写入Parcel中，也就是说Bundle也是使用Parcel传递的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">public final void writeValue(Object v) &#123;</div><div class="line">    <span class="keyword">if</span> (v == null) &#123;</div><div class="line">        writeInt(VAL_NULL);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof String) &#123;</div><div class="line">        writeInt(VAL_STRING);</div><div class="line">        writeString((String) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Integer) &#123;</div><div class="line">        writeInt(VAL_INTEGER);</div><div class="line">        writeInt((Integer) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Map) &#123;</div><div class="line">        writeInt(VAL_MAP);</div><div class="line">        writeMap((Map) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Bundle) &#123;</div><div class="line">        // Must be before Parcelable</div><div class="line">        writeInt(VAL_BUNDLE);</div><div class="line">        writeBundle((Bundle) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Parcelable) &#123;</div><div class="line">        writeInt(VAL_PARCELABLE);</div><div class="line">        writeParcelable((Parcelable) v, 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Short) &#123;</div><div class="line">        writeInt(VAL_SHORT);</div><div class="line">        writeInt(((Short) v).intValue());</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Long) &#123;</div><div class="line">        writeInt(VAL_LONG);</div><div class="line">        writeLong((Long) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Float) &#123;</div><div class="line">        writeInt(VAL_FLOAT);</div><div class="line">        writeFloat((Float) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Double) &#123;</div><div class="line">        writeInt(VAL_DOUBLE);</div><div class="line">        writeDouble((Double) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Boolean) &#123;</div><div class="line">        writeInt(VAL_BOOLEAN);</div><div class="line">        writeInt((Boolean) v ? 1 : 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof CharSequence) &#123;</div><div class="line">        // Must be after String</div><div class="line">        writeInt(VAL_CHARSEQUENCE);</div><div class="line">        writeCharSequence((CharSequence) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof List) &#123;</div><div class="line">        writeInt(VAL_LIST);</div><div class="line">        writeList((List) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof SparseArray) &#123;</div><div class="line">        writeInt(VAL_SPARSEARRAY);</div><div class="line">        writeSparseArray((SparseArray) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof boolean[]) &#123;</div><div class="line">        writeInt(VAL_BOOLEANARRAY);</div><div class="line">        writeBooleanArray((boolean[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof byte[]) &#123;</div><div class="line">        writeInt(VAL_BYTEARRAY);</div><div class="line">        writeByteArray((byte[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof String[]) &#123;</div><div class="line">        writeInt(VAL_STRINGARRAY);</div><div class="line">        writeStringArray((String[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof CharSequence[]) &#123;</div><div class="line">        // Must be after String[] and before Object[]</div><div class="line">        writeInt(VAL_CHARSEQUENCEARRAY);</div><div class="line">        writeCharSequenceArray((CharSequence[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof IBinder) &#123;</div><div class="line">        writeInt(VAL_IBINDER);</div><div class="line">        writeStrongBinder((IBinder) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Parcelable[]) &#123;</div><div class="line">        writeInt(VAL_PARCELABLEARRAY);</div><div class="line">        writeParcelableArray((Parcelable[]) v, 0);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof int[]) &#123;</div><div class="line">        writeInt(VAL_INTARRAY);</div><div class="line">        writeIntArray((int[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof long[]) &#123;</div><div class="line">        writeInt(VAL_LONGARRAY);</div><div class="line">        writeLongArray((long[]) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Byte) &#123;</div><div class="line">        writeInt(VAL_BYTE);</div><div class="line">        writeInt((Byte) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof PersistableBundle) &#123;</div><div class="line">        writeInt(VAL_PERSISTABLEBUNDLE);</div><div class="line">        writePersistableBundle((PersistableBundle) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Size) &#123;</div><div class="line">        writeInt(VAL_SIZE);</div><div class="line">        writeSize((Size) v);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof SizeF) &#123;</div><div class="line">        writeInt(VAL_SIZEF);</div><div class="line">        writeSizeF((SizeF) v);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Class&lt;?&gt; clazz = v.getClass();</div><div class="line">        <span class="keyword">if</span> (clazz.isArray() &amp;&amp; clazz.getComponentType() == Object.class) &#123;</div><div class="line">            // Only pure Object[] are written here, Other arrays of non-primitive types are</div><div class="line">            // handled by serialization as this does not record the component type.</div><div class="line">            writeInt(VAL_OBJECTARRAY);</div><div class="line">            writeArray((Object[]) v);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v instanceof Serializable) &#123;</div><div class="line">            // Must be last</div><div class="line">            writeInt(VAL_SERIALIZABLE);</div><div class="line">            writeSerializable((Serializable) v);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            throw new RuntimeException(<span class="string">"Parcel: unable to marshal value "</span> + v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要写入Parcel的对象要先判断类型，然后先写入该对象的类型标志，再调用对应类型的方法写入要保存数据。这里需要关注的只有一点，就是Map类型的对象保存，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public final void writeMap(Map val) &#123;</div><div class="line">       writeMapInternal((Map&lt;String, Object&gt;) val);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> void writeMapInternal(Map&lt;String,Object&gt; val) &#123;</div><div class="line">       <span class="keyword">if</span> (val == null) &#123;</div><div class="line">           writeInt(-1);</div><div class="line">           <span class="built_in">return</span>;</div><div class="line">       &#125;</div><div class="line">       Set&lt;Map.Entry&lt;String,Object&gt;&gt; entries = val.entrySet();</div><div class="line">       writeInt(entries.size());</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; e : entries) &#123;</div><div class="line">           writeValue(e.getKey());</div><div class="line">           writeValue(e.getValue());</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>Parcel只是获取Map的键值对，然后保存，该方法没有保存Map类的信息，也就是类型擦除，最后经过startActivity跳到其他Activity时，再获取时所以Map类型对象都会转换为HashMap对象，所以Bundle传递数据不能使用其他Map类型，比如TreeMap。</p>
<h3 id="Parcel转换为类型对象"><a href="#Parcel转换为类型对象" class="headerlink" title="Parcel转换为类型对象"></a>Parcel转换为类型对象</h3><p>这里还是从Intent类看起，Intent实现了Parcelable，ActivityManagerProxy的startActivity方法中intent.writeToParcel(data, 0);通过这个方法Intent把对象的具体信息写入Parcel中，通过一连串的传输最后又通过序列化转为Intent对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">protected Intent(Parcel <span class="keyword">in</span>) &#123;</div><div class="line">        <span class="built_in">read</span>FromParcel(<span class="keyword">in</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void <span class="built_in">read</span>FromParcel(Parcel <span class="keyword">in</span>) &#123;</div><div class="line">        //恢复action属性</div><div class="line">        <span class="built_in">set</span>Action(in.readString());</div><div class="line">        //恢复Data属性</div><div class="line">        mData = Uri.CREATOR.createFromParcel(<span class="keyword">in</span>);</div><div class="line">        //Type属性</div><div class="line">        mType = in.readString();</div><div class="line">        //Flag属性,启动模式</div><div class="line">        mFlags = in.readInt();</div><div class="line">        mPackage = in.readString();</div><div class="line">        mComponent = ComponentName.readFromParcel(<span class="keyword">in</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mSourceBounds = Rect.CREATOR.createFromParcel(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int N = in.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt; 0) &#123;</div><div class="line">            mCategories = new ArraySet&lt;String&gt;();</div><div class="line">            int i;</div><div class="line">            <span class="keyword">for</span> (i=0; i&lt;N; i++) &#123;</div><div class="line">                mCategories.add(in.readString().intern());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mCategories = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mSelector = new Intent(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (in.readInt() != 0) &#123;</div><div class="line">            mClipData = new ClipData(<span class="keyword">in</span>);</div><div class="line">        &#125;</div><div class="line">        mContentUserHint = in.readInt();</div><div class="line">        //传递的数据</div><div class="line">        mExtras = in.readBundle();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>使用过Parcelable的都知道反序列化最后都会调用包含Parcel参数的构造函数，对于Intent就是Intent(Parcel in)，然后调用readFromParcel方法，把Intent的相关属性恢复。对于Bundle数据的恢复是调用了Parcel的readBundle方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">//Parcel.java </div><div class="line">public final Bundle <span class="function"><span class="title">readBundle</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">read</span>Bundle(null);</div><div class="line">&#125;</div><div class="line">//Parcel.java </div><div class="line">public final Bundle <span class="built_in">read</span>Bundle(ClassLoader loader) &#123;</div><div class="line">    //获取Bundle保存数据的长度</div><div class="line">    int length = <span class="built_in">read</span>Int();</div><div class="line">    <span class="keyword">if</span> (length &lt; 0) &#123;</div><div class="line">        <span class="keyword">if</span> (Bundle.DEBUG) Log.d(TAG, <span class="string">"null bundle: length="</span> + length);</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    final Bundle bundle = new Bundle(this, length);</div><div class="line">    <span class="keyword">if</span> (loader != null) &#123;</div><div class="line">        bundle.setClassLoader(loader);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> bundle;</div><div class="line">&#125;</div><div class="line">//Bundle.java</div><div class="line">Bundle(Parcel parcelledData, int length) &#123;</div><div class="line">    super(parcelledData, length);</div><div class="line"></div><div class="line">    mHasFds = mParcelledData.hasFileDescriptors();</div><div class="line">    mFdsKnown = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">//BaseBundle.java</div><div class="line">BaseBundle(Parcel parcelledData, int length) &#123;</div><div class="line">    <span class="built_in">read</span>FromParcelInner(parcelledData, length);</div><div class="line">&#125;</div><div class="line">//BaseBundle.java</div><div class="line">private void <span class="built_in">read</span>FromParcelInner(Parcel parcel, int length) &#123;</div><div class="line">    <span class="keyword">if</span> (length == 0) &#123;</div><div class="line">        // Empty Bundle or end of data.</div><div class="line">        mParcelledData = EMPTY_PARCEL;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    //获取数据类型魔数，若不为BUNDLE_MAGIC，则抛出异常。</div><div class="line">    int magic = parcel.readInt();</div><div class="line">    <span class="keyword">if</span> (magic != BUNDLE_MAGIC) &#123;</div><div class="line">        //noinspection ThrowableInstanceNeverThrown</div><div class="line">        throw new IllegalStateException(<span class="string">"Bad magic number for Bundle: 0x"</span></div><div class="line">                + Integer.toHexString(magic));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Advance within this Parcel</div><div class="line">    int offset = parcel.dataPosition();</div><div class="line">    parcel.setDataPosition(offset + length);</div><div class="line"></div><div class="line">    Parcel p = Parcel.obtain();</div><div class="line">    p.setDataPosition(0);</div><div class="line">    //通过传入的Parcel对象生成一个新的Parcel对象，也就是截取Parcel的数据组成新的Parcel对象。</div><div class="line">    p.appendFrom(parcel, offset, length);</div><div class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Retrieving "</span>  + Integer.toHexString(System.identityHashCode(this))</div><div class="line">            + <span class="string">": "</span> + length + <span class="string">" bundle bytes starting at "</span> + offset);</div><div class="line">    p.setDataPosition(0);</div><div class="line">    //然后把新生成的Parcel赋值给Bundle。</div><div class="line">    mParcelledData = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Intent的readBundle方法没有直接的把Parcel数据解析为对象数据，还是以Parcel形式保存着，那Parcel是什么时候解析的呢？然后我查看了一下Bundle的get方法，发现最后都调用了unparcel()。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public byte getByte(String key) &#123;</div><div class="line">    <span class="built_in">return</span> super.getByte(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">byte getByte(String key) &#123;</div><div class="line">    unparcel();</div><div class="line">    <span class="built_in">return</span> getByte(key, (byte) 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就开始研究unparcel()方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">synchronized void <span class="function"><span class="title">unparcel</span></span>() &#123;</div><div class="line">      //没有Parcel数据，不创建mMap对象，直接返回</div><div class="line">      <span class="keyword">if</span> (mParcelledData == null) &#123;</div><div class="line">          <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">                  + <span class="string">": no parcelled data"</span>);</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      //mParcelledData为默认的EMPTY_PARCEL，创建或清理mMap对象，不解析数据，直接返回</div><div class="line">      <span class="keyword">if</span> (mParcelledData == EMPTY_PARCEL) &#123;</div><div class="line">          <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">                  + <span class="string">": empty"</span>);</div><div class="line">          <span class="keyword">if</span> (mMap == null) &#123;</div><div class="line">              mMap = new ArrayMap&lt;String, Object&gt;(1);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              mMap.erase();</div><div class="line">          &#125;</div><div class="line">          mParcelledData = null;</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      //解析Parcel数据，或取Parcel含有多少键值对数据</div><div class="line">      int N = mParcelledData.readInt();</div><div class="line">      <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">              + <span class="string">": reading "</span> + N + <span class="string">" maps"</span>);</div><div class="line">      <span class="keyword">if</span> (N &lt; 0) &#123;</div><div class="line">          <span class="built_in">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (mMap == null) &#123;</div><div class="line">          mMap = new ArrayMap&lt;String, Object&gt;(N);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          mMap.erase();</div><div class="line">          mMap.ensureCapacity(N);</div><div class="line">      &#125;</div><div class="line">      //核心功能读取数据放入mMap中</div><div class="line">      mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);</div><div class="line">      mParcelledData.recycle();</div><div class="line">      mParcelledData = null;</div><div class="line">      <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"unparcel "</span> + Integer.toHexString(System.identityHashCode(this))</div><div class="line">              + <span class="string">" final map: "</span> + mMap);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>unparcel方法的就是判断当前的Bundle是否含有Parcel数据，然后根据结果创建mMap对象，然后调用readArrayMapInternal把Parcel中的数据发序列化为对象。然后存放在mMap中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void <span class="built_in">read</span>ArrayMapInternal(ArrayMap outVal, int N,</div><div class="line">        ClassLoader loader) &#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG_ARRAY_MAP) &#123;</div><div class="line">            RuntimeException here =  new RuntimeException(<span class="string">"here"</span>);</div><div class="line">            here.fillInStackTrace();</div><div class="line">            Log.d(TAG, <span class="string">"Reading "</span> + N + <span class="string">" ArrayMap entries"</span>, here);</div><div class="line">        &#125;</div><div class="line">        int startPos;</div><div class="line">        <span class="keyword">while</span> (N &gt; 0) &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) startPos = dataPosition();</div><div class="line">            String key = <span class="built_in">read</span>String();</div><div class="line">            Object value = <span class="built_in">read</span>Value(loader);</div><div class="line">            <span class="keyword">if</span> (DEBUG_ARRAY_MAP) Log.d(TAG, <span class="string">"  Read #"</span> + (N-1) + <span class="string">" "</span></div><div class="line">                    + (dataPosition()-startPos) + <span class="string">" bytes: key=0x"</span></div><div class="line">                    + Integer.toHexString((key != null ? key.hashCode() : 0)) + <span class="string">" "</span> + key);</div><div class="line">            outVal.append(key, value);</div><div class="line">            N--;</div><div class="line">        &#125;</div><div class="line">        outVal.validate();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到先读取了key，然后调用readValue获取value的值，然后存储到mMap中。我在这里主要分析一下Map类型数据的获取，可以很明了的知道为什么强制为TreeMap会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> public final Object <span class="built_in">read</span>Value(ClassLoader loader) &#123;</div><div class="line">     int <span class="built_in">type</span> = <span class="built_in">read</span>Int();</div><div class="line"></div><div class="line">     switch (<span class="built_in">type</span>) &#123;</div><div class="line">     <span class="keyword">case</span> VAL_NULL:</div><div class="line">         <span class="built_in">return</span> null;</div><div class="line">     ...</div><div class="line">     省略</div><div class="line">     ...</div><div class="line">     <span class="keyword">case</span> VAL_MAP:</div><div class="line">         <span class="built_in">return</span> <span class="built_in">read</span>HashMap(loader);</div><div class="line">     ...</div><div class="line">     省略</div><div class="line">     ...</div><div class="line">     </div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public final HashMap <span class="built_in">read</span>HashMap(ClassLoader loader)</div><div class="line"> &#123;</div><div class="line">     int N = <span class="built_in">read</span>Int();</div><div class="line">     <span class="keyword">if</span> (N &lt; 0) &#123;</div><div class="line">         <span class="built_in">return</span> null;</div><div class="line">     &#125;</div><div class="line">     HashMap m = new HashMap(N);</div><div class="line">     <span class="built_in">read</span>MapInternal(m, N, loader);</div><div class="line">     <span class="built_in">return</span> m;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>一切都很明了，Parcel对Map类型的数据进行反序列化时，获取key\value的值都存放在HashMap中，然后返回HashMap，也就是说所有Map类型数据最后都会转为HashMap类型数据。强制当然会报错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/02/Android-Bundle/" data-id="civafvvk700001gs2ug3c1jgp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/06/内存泄露/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android内存泄露
        
      </div>
    </a>
  
  
    <a href="/2016/10/31/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java 动态代理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/09/View-Context-leak/">Android 输入法导致内存泄露以及WebView内存泄露解决方案</a>
          </li>
        
          <li>
            <a href="/2016/11/06/内存泄露/">Android内存泄露</a>
          </li>
        
          <li>
            <a href="/2016/11/02/Android-Bundle/">Bundle、Parcel解析</a>
          </li>
        
          <li>
            <a href="/2016/10/31/hello-world/">Java 动态代理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>