<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android 输入法导致内存泄露以及WebView内存泄露解决方案 | xingtangcunliu个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如果开发到一定程度肯定会去处理内存的问题，因为不处理该问题的话，轻一点会导致应用频繁GC，严重的情况下会产生内存溢出导致崩溃。而只要讲到内存溢出经常会遇到一句话，使用Activity的Context导致，而Context被引用，最后导致Activity泄露。
1、查找泄露原因既然是查询View持有Activity的引用导致的内存泄露，那么就从Activity的setContentView看起。12">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 输入法导致内存泄露以及WebView内存泄露解决方案">
<meta property="og:url" content="http://yoursite.com/2016/11/09/View-Context-leak/index.html">
<meta property="og:site_name" content="xingtangcunliu个人博客">
<meta property="og:description" content="如果开发到一定程度肯定会去处理内存的问题，因为不处理该问题的话，轻一点会导致应用频繁GC，严重的情况下会产生内存溢出导致崩溃。而只要讲到内存溢出经常会遇到一句话，使用Activity的Context导致，而Context被引用，最后导致Activity泄露。
1、查找泄露原因既然是查询View持有Activity的引用导致的内存泄露，那么就从Activity的setContentView看起。12">
<meta property="og:updated_time" content="2016-11-09T12:52:57.612Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 输入法导致内存泄露以及WebView内存泄露解决方案">
<meta name="twitter:description" content="如果开发到一定程度肯定会去处理内存的问题，因为不处理该问题的话，轻一点会导致应用频繁GC，严重的情况下会产生内存溢出导致崩溃。而只要讲到内存溢出经常会遇到一句话，使用Activity的Context导致，而Context被引用，最后导致Activity泄露。
1、查找泄露原因既然是查询View持有Activity的引用导致的内存泄露，那么就从Activity的setContentView看起。12">
  
    <link rel="alternate" href="/atom.xml" title="xingtangcunliu个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xingtangcunliu个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-View-Context-leak" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/View-Context-leak/" class="article-date">
  <time datetime="2016-11-08T16:24:50.000Z" itemprop="datePublished">2016-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android 输入法导致内存泄露以及WebView内存泄露解决方案
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果开发到一定程度肯定会去处理内存的问题，因为不处理该问题的话，轻一点会导致应用频繁GC，严重的情况下会产生内存溢出导致崩溃。而只要讲到内存溢出经常会遇到一句话，使用Activity的Context导致，而Context被引用，最后导致Activity泄露。</p>
<h2 id="1、查找泄露原因"><a href="#1、查找泄露原因" class="headerlink" title="1、查找泄露原因"></a>1、查找泄露原因</h2><p>既然是查询View持有Activity的引用导致的内存泄露，那么就从Activity的setContentView看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过代码一步一步查找，发现最后是实现了PhoneWindow的setContentView的方法。PhoneWindow位于\frameworks\base\policy\src\com\android\internal\policy\impl\PhoneWondow.java;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">    // before this happens.</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        installDecor();</div><div class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        mContentParent.removeAllViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                getContext());</div><div class="line">        transitionTo(newScene);</div><div class="line">    &#125; else &#123;</div><div class="line">        //最后还是在这里实现，如果mContentParent不为null，mContentParent直接把layoutResID的布局添加到根布局</div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">    &#125;</div><div class="line">    mContentParent.requestApplyInsets();</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看见Activity的setContentView（int layoutRes）最后还是用LayoutInflater实现了。那我们再看mLayoutInflater是什么时候生成的，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public PhoneWindow(Context context) &#123;</div><div class="line">    super(context);</div><div class="line">    mLayoutInflater = LayoutInflater.from(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出是在PhoneWindow生成时一起生成的，那么PhoneWindow什么生成的，继续看Activityd的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">           Instrumentation instr, IBinder token, int ident,</div><div class="line">           Application application, Intent intent, ActivityInfo info,</div><div class="line">           CharSequence title, Activity parent, String id,</div><div class="line">           NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">           Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</div><div class="line">       attachBaseContext(context);</div><div class="line"></div><div class="line">       mFragments.attachHost(null /*parent*/);</div><div class="line">       //这里可以看出把Activity当成Context传给PhoneWindow了，并用这个Context生成了LayoutInflater。</div><div class="line">       mWindow = new PhoneWindow(this);</div><div class="line">      ....</div><div class="line">      省略</div><div class="line">      ....</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到Activity传递到了PhoneWindow，并通过Activity生成了LayoutInflater。这里记住，下面分析时要用到。</p>
<p>既然是Activity被View持有，那么我们就从View何时被赋值Context出发。那么我先列出View有多少种生成方法。<br>1、构造函数生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public View(Context context) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对构造函数生成，可以看出在这个方法中我们可以直接控制Context,也就是说我们自己可以控制是否直接使用Activity，可以直接使用Application，当然会出些问题，原因以及解决方法下面再说。</p>
<p>2、LayoutInflater方法生成</p>
<p>然后再看LayoutInflater如何生成View，在这之前我先找到LayoutInflater的实现类，因为你会发现LayoutInflater是抽象的。现在从LayoutInflater的生成方法开始看起。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Obtains the LayoutInflater from the given context.</div><div class="line">    */</div><div class="line">   public static LayoutInflater from(Context context) &#123;</div><div class="line">       LayoutInflater LayoutInflater =</div><div class="line">               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">       <span class="keyword">if</span> (LayoutInflater == null) &#123;</div><div class="line">           throw new AssertionError(<span class="string">"LayoutInflater not found."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="built_in">return</span> LayoutInflater;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>调用context的getSystemService方法，一直往上找会发现最后调用了ContextImpl的getSystemService的方法。<br>LayoutInflater实例化的地方为ContextImpl,位于\frameworks\base\core\java\android\app\ContextImpl.java。代码为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line"> ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line"> registerService(LAYOUT_INFLATER_SERVICE, new <span class="function"><span class="title">ServiceFetcher</span></span>() &#123;</div><div class="line">                public Object createService(ContextImpl ctx) &#123;</div><div class="line">                    <span class="built_in">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</div><div class="line">                &#125;&#125;);</div><div class="line"> ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过一步一步的代码跟踪，发现了LayoutInflater的实现类BridgeInflater,位于frameworks\base\tools\layoutlib\bridge\src\android\view\BridgeInflater.java,在这我们只需要关心onCreateView方法。<br>最后调用PolicyManager的makeNewLayoutInflater方法生成，同时传入ctx.getOuterContext()，这就是LayoutInflater所持有的Context，这就是ContextImpl生成时传入ContextImpl的Context。ContextImpl的对象生成代码位于\frameworks\base\core\java\android\app\ActivityThread.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private Context createBaseContextForActivity(ActivityClientRecord r,</div><div class="line">            final Activity activity) &#123;</div><div class="line">        生成ContextImpl并把Activity通过setOuterContext方法赋值给ContextImpl。</div><div class="line">        ContextImpl appContext = new ContextImpl();</div><div class="line">        appContext.init(r.packageInfo, r.token, this);</div><div class="line">        appContext.setOuterContext(activity);</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">        return baseContext;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出Activity和ContextImpl互相持有，那么Application和ContextImpl也互相持有。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line">public final class BridgeInflater extends LayoutInflater &#123;</div><div class="line"></div><div class="line">    private final IProjectCallback mProjectCallback;</div><div class="line">    private boolean mIsInMerge = <span class="literal">false</span>;</div><div class="line">    private ResourceReference mResourceReference;</div><div class="line"></div><div class="line">    private static final String[] sClassPrefixList = &#123;</div><div class="line">        <span class="string">"android.widget."</span>,</div><div class="line">        <span class="string">"android.webkit."</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    protected BridgeInflater(LayoutInflater original, Context newContext) &#123;</div><div class="line">        //把Context传递给LayoutInflater父类</div><div class="line">        super(original, newContext);</div><div class="line">        mProjectCallback = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BridgeInflater(Context context, IProjectCallback projectCallback) &#123;</div><div class="line">        //把Context传递给LayoutInflater父类</div><div class="line">        super(context);</div><div class="line">        mProjectCallback = projectCallback;</div><div class="line">        mConstructorArgs[0] = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123;</div><div class="line">        View view = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">                try &#123;</div><div class="line">                    //调用LayoutInflater的createView方法</div><div class="line">                    view = createView(name, prefix, attrs);</div><div class="line">                    <span class="keyword">if</span> (view != null) &#123;</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                    // Ignore. We<span class="string">'ll try again using the base class below.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                if (view == null) &#123;</div><div class="line">                    view = super.onCreateView(name, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                // Ignore. We'll try again using the custom view loader below.</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Finally try again using the custom view loader</div><div class="line">            try &#123;</div><div class="line">                <span class="keyword">if</span> (view == null) &#123;</div><div class="line">                    view = loadCustomView(name, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                // If the class was not found, we throw the exception directly, because this</div><div class="line">                // method is already expected to throw it.</div><div class="line">                throw e;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            // Wrap the real exception <span class="keyword">in</span> a ClassNotFoundException, so that the calling method</div><div class="line">            // can deal with it.</div><div class="line">            ClassNotFoundException exception = new ClassNotFoundException(<span class="string">"onCreateView"</span>, e);</div><div class="line">            throw exception;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setupViewInContext(view, attrs);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View createViewFromTag(View parent, String name, AttributeSet attrs) &#123;</div><div class="line">        View view = null;</div><div class="line">        try &#123;</div><div class="line">            //调用LayoutInflater的createViewFromTag方法</div><div class="line">            view = super.createViewFromTag(parent, name, attrs);</div><div class="line">        &#125; catch (InflateException e) &#123;</div><div class="line">            // try to load the class from using the custom view loader</div><div class="line">            try &#123;</div><div class="line">                view = loadCustomView(name, attrs);</div><div class="line">            &#125; catch (Exception e2) &#123;</div><div class="line">                // Wrap the real exception <span class="keyword">in</span> an InflateException so that the calling</div><div class="line">                // method can deal with it.</div><div class="line">                InflateException exception = new InflateException();</div><div class="line">                <span class="keyword">if</span> (e2.getClass().equals(ClassNotFoundException.class) == <span class="literal">false</span>) &#123;</div><div class="line">                    exception.initCause(e2);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    exception.initCause(e);</div><div class="line">                &#125;</div><div class="line">                throw exception;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setupViewInContext(view, attrs);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View inflate(int resource, ViewGroup root) &#123;</div><div class="line">        Context context = getContext();</div><div class="line">        <span class="keyword">if</span> (context instanceof BridgeContext) &#123;</div><div class="line">            BridgeContext bridgeContext = (BridgeContext)context;</div><div class="line"></div><div class="line">            ResourceValue value = null;</div><div class="line"></div><div class="line">            Pair&lt;ResourceType, String&gt; layoutInfo = Bridge.resolveResourceId(resource);</div><div class="line">            <span class="keyword">if</span> (layoutInfo != null) &#123;</div><div class="line">                value = bridgeContext.getRenderResources().getFrameworkResource(</div><div class="line">                        ResourceType.LAYOUT, layoutInfo.getSecond());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                layoutInfo = mProjectCallback.resolveResourceId(resource);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (layoutInfo != null) &#123;</div><div class="line">                    value = bridgeContext.getRenderResources().getProjectResource(</div><div class="line">                            ResourceType.LAYOUT, layoutInfo.getSecond());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (value != null) &#123;</div><div class="line">                File f = new File(value.getValue());</div><div class="line">                <span class="keyword">if</span> (f.isFile()) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        XmlPullParser parser = ParserFactory.create(f);</div><div class="line"></div><div class="line">                        BridgeXmlBlockParser bridgeParser = new BridgeXmlBlockParser(</div><div class="line">                                parser, bridgeContext, <span class="literal">false</span>);</div><div class="line">                        //调用LayoutInflater的inflate方法</div><div class="line">                        <span class="built_in">return</span> inflate(bridgeParser, root);</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ,</div><div class="line">                                <span class="string">"Failed to parse file "</span> + f.getAbsolutePath(), e, null /*data*/);</div><div class="line"></div><div class="line">                        <span class="built_in">return</span> null;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">  ....</div><div class="line">  省略</div><div class="line">  ....</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后还是会调用LayoutInflater的inflate的方法；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123;</div><div class="line">   <span class="built_in">return</span> inflate(parser, root, root != null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">         Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></div><div class="line">                 + Integer.toHexString(resource) + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    //获取页面的xml资源解析</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        //解析xml资源文件</div><div class="line">        <span class="built_in">return</span> inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Context inflaterContext = mContext;</div><div class="line">    final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">    Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">    //设置View构造函数的参数，设置Context参数为LayoutInflater自带的context，下面createView方法会使用到。</div><div class="line">    mConstructorArgs[0] = inflaterContext;</div><div class="line">    ....</div><div class="line">    省略</div><div class="line">    ....</div><div class="line">    //创建View</div><div class="line">    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line">    ....</div><div class="line">    省略</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码就是创建的一下流程，可以看出View是LayoutInflater创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;</div><div class="line">    return createViewFromTag(parent, name, context, attrs, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">      ....</div><div class="line">       省略</div><div class="line">      ....</div><div class="line">        //View 最后调用了onCreateView方法生成了View，mFactory2、mFactory默认为null，最后会调用onCreateView方法。</div><div class="line">        View view;</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还是到了createView方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static final Class&lt;?&gt;[] mConstructorSignature = new Class[] &#123;</div><div class="line">        Context.class, AttributeSet.class&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line"></div><div class="line">        //获取默认构造，使用View(Context context, @Nullable AttributeSet attrs)</div><div class="line">        constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">        constructor.setAccessible(<span class="literal">true</span>);</div><div class="line">        sConstructorMap.put(name, constructor);</div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //此处args参数中args[0]已结设置为LayoutInflater,上面中已经提及。</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        <span class="keyword">if</span> (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(<span class="built_in">clone</span>InContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> view;</div><div class="line"></div><div class="line">        ....</div><div class="line">        省略</div><div class="line">        ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面分析可以看出最后和View绑定的Context就是LayoutInflater所持有的Context。这时我们就要着重分析LayoutInflater持有的Context到底是不是Context，如果是那么是什么时候赋值的，那我们再研究一下LayoutInflater的生成方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static LayoutInflater from(Context context) &#123;</div><div class="line">    LayoutInflater LayoutInflater =</div><div class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    if (LayoutInflater == null) &#123;</div><div class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</div><div class="line">    &#125;</div><div class="line">  return LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果研究过Activity和Application的源码我们会发现Activity的源码继承类比Activity多了一层，那就是Activity继承于ContextThemeWrapper，而Application继承于ContextWrapper，他们都对getSystemService方法进行了重写，ContextThemeWrapper的重写代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override public Object getSystemService(String name) &#123;</div><div class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</div><div class="line">        if (mInflater == null) &#123;</div><div class="line">            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);</div><div class="line">        &#125;</div><div class="line">        return mInflater;</div><div class="line">    &#125;</div><div class="line">    return getBaseContext().getSystemService(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而ContextWrapper重写的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return mBase.getSystemService(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ContextThemeWrapper继承于ContextWrapper，而getBaseContext()方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Context getBaseContext() &#123;</div><div class="line">   return mBase;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出ContextThemeWrapper和ContextWrapper最终实现除了cloneInContext方法外都一样，最终都是通过自己持有的ContextImpl对象执行getSystemService方法来获取LayoutInflater对象。而前面分析可知最终都会用ContextImpl对象所持有的mOuterContext对象，即Application和Activity生成LayoutInflater对象，进而LayoutInflater对象持有Activity或Application。我们在看一下ContextThemeWrapper重写中用到的cloneInContext方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public LayoutInflater cloneInContext(Context newContext) &#123;</div><div class="line">      return new BridgeInflater(this, newContext);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看出该方法的作用就是克隆，只是把新生成LayoutInflater对象的Context对象替换掉。其实我有点不明白，因为ContextImpl方法中生成LayoutInflater用到的Context就是Activity本身，为什么还要这一步。到这一步可以很容易的看出View为什么会持有Activity了。逻辑整理如下：</p>
<p>PhoneWindow 用Activity生成LayoutInflater</p>
<p>LayoutInflater对象持有Activity；</p>
<p>LayoutInflater在生成View对象时把Activity赋值给View，</p>
<p>View 持有Activity的引用。</p>
<p>##2、解决方案##</p>
<p>我的思路很简单既然是因为View持有Activity的引用，那就不让Activity的强引用就可以了。</p>
<p>从以上代码分析可以看出Activity之所以会被持有都是因为PhoneWindow中生成LayoutInflater对象调用了Activity的getSystemService方法。该方法生成的对象持有Activity对象的引用。一开始我准备直接在BaseActivity中重写的getSystemService方法。最早为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> public Object getSystemService(String name) &#123;</div><div class="line">    if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</div><div class="line">        if (mInflater == null) &#123;</div><div class="line">            //使用代理类</div><div class="line">            baseContextWrappernew = new BaseContextWrapper(this);</div><div class="line">            mInflater = LayoutInflater.from(BaseApplication.getInstance());</div><div class="line">        &#125;</div><div class="line">        return mInflater;</div><div class="line">    &#125;</div><div class="line">return super.getSystemService(name);</div></pre></td></tr></table></figure>
<p>但这种方法有个严重的问题，就是Activity的很多主题样式不能使用了，所以有看了ContextThemeWrapper的方法，自己继承ContextWrapper类，重写其中的几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">//创建代理类</div><div class="line">public class BaseContextWrapper extends ContextWrapper &#123;</div><div class="line"></div><div class="line">    static Field field;</div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            field = ContextWrapper.class.getDeclaredField(&quot;mBase&quot;);</div><div class="line">            field.setAccessible(true);</div><div class="line">        &#125; catch (NoSuchFieldException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Context mContext;</div><div class="line">    public BaseContextWrapper(Context context) &#123;</div><div class="line">        super(null);</div><div class="line">        mContext = context;</div><div class="line">        if(context instanceof ContextWrapper)&#123;</div><div class="line">            context = ((ContextWrapper)context).getBaseContext();</div><div class="line">        &#125;</div><div class="line">        attachBaseContext(context);</div><div class="line">    &#125;</div><div class="line">    //当获取主题信息时直接调用Activity的getTheme方法。</div><div class="line">    @Override</div><div class="line">    public Resources.Theme getTheme() &#123;</div><div class="line">        if(mContext != null)&#123;</div><div class="line">            return mContext.getTheme();</div><div class="line">        &#125;</div><div class="line">        return super.getTheme();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public Object getSystemService(String name) &#123;</div><div class="line">        if(mContext == null)&#123;</div><div class="line">            return super.getSystemService(name);</div><div class="line">        &#125;</div><div class="line">        return mContext.getSystemService(name);</div><div class="line">    &#125;</div><div class="line">    //释放Activity的持有。</div><div class="line">    public void recycle()&#123;</div><div class="line">        try &#123;</div><div class="line">            field.set(this,null);</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Activity getActivityContext()&#123;</div><div class="line">        Activity context = (Activity) mContext;</div><div class="line">        return context;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样View就只会持有BaseContextWrapper对象，当Activity销毁时会执行recycle方法释放Activity已经ContextImpl。这样View已经不能直接持有Activity了，但还有一个问题就是View本身持有包含它的ViewGroup就是ViewParent，这里只需要去除持有关系即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ViewGroup viewGroup = (ViewGroup) getWindow().getDecorView();</div><div class="line">//去除方法要在BaseContextWrapper的recycle方法之前执行。</div><div class="line">clearView(viewGroup);</div><div class="line">if(baseContextWrappernew != null)&#123;</div><div class="line">   baseContextWrappernew.recycle();</div><div class="line">&#125;</div><div class="line">private void clearView(View viewClear)&#123;</div><div class="line">    if(viewClear instanceof ViewGroup)&#123;</div><div class="line">        int length = ((ViewGroup)viewClear).getChildCount();</div><div class="line">        View view = null;</div><div class="line">        for(int i=0;i&lt; length;i++)&#123;</div><div class="line">            view = ((ViewGroup) viewClear).getChildAt(i);</div><div class="line">            clearView(view);</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">           ((ViewGroup) viewClear).removeAllViews();</div><div class="line">        &#125; catch(Exception e)&#123;</div><div class="line">        &#125;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些只是清楚了VIew和Activity的基本持有关系，但各种事件监听之类的要自己注意去除。</p>
<p>##3、LayoutInflater 的Activity or Application##<br>从我上面的分析其实已经可以看出了部分区别。</p>
<p>1、就是用Activity那么View持有的Context就是Activity，如果用的是Application那么View持有的Context就是Application，而有些人比较喜欢直接用View的Context转为Activity，如果用Application那时就会出错。<br>2、Application继承自ContextWrapper，而Activity继承自ContextThemeWrapper，而ContextThemeWrapper有时对ContextWrapper的继承，对其中一部分方法进行了修改，这也就是不同所在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//在Activity生成时会获取Activity的主题，并调用该方法</div><div class="line"> @Override public void setTheme(int resid) &#123;</div><div class="line">        mThemeResource = resid;</div><div class="line">        initializeTheme();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /** @hide */</div><div class="line">    @Override</div><div class="line">    public int getThemeResId() &#123;</div><div class="line">        return mThemeResource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public Resources.Theme getTheme() &#123;</div><div class="line">        if (mTheme != null) &#123;</div><div class="line">            return mTheme;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mThemeResource = Resources.selectDefaultTheme(mThemeResource,</div><div class="line">                getApplicationInfo().targetSdkVersion);</div><div class="line">        initializeTheme();</div><div class="line"></div><div class="line">        return mTheme;</div><div class="line">    &#125;</div><div class="line">    //Activity的主题产生作用。覆盖Application的相同属性</div><div class="line">    protected void onApplyThemeResource(Resources.Theme theme, int resid, boolean first) &#123;</div><div class="line">        theme.applyStyle(resid, true);</div><div class="line">    &#125;</div><div class="line">    //生成主题并获取Application的主题赋值给新主题，并使Activity的主题产生作用。</div><div class="line">    private void initializeTheme() &#123;</div><div class="line">        final boolean first = mTheme == null;</div><div class="line">        if (first) &#123;</div><div class="line">            mTheme = getResources().newTheme();</div><div class="line">            Resources.Theme theme = mBase.getTheme();</div><div class="line">            if (theme != null) &#123;</div><div class="line">                mTheme.setTo(theme);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //Activity的主题产生作用。</div><div class="line">        onApplyThemeResource(mTheme, mThemeResource, first);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里就已经产生基本的不同了，比如EditText 的字体颜色 设置属性为？textcolor,这时如果Application设置为黑色，而Activity的主题中设置为红色，那么如果这个Activity的某个EditText用了Application，那么这时字体会显示黑色而不是预期的红色。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/09/View-Context-leak/" data-id="civaxfqn200000os2wlwhcqms" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/11/06/内存泄露/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Android内存泄露</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/09/View-Context-leak/">Android 输入法导致内存泄露以及WebView内存泄露解决方案</a>
          </li>
        
          <li>
            <a href="/2016/11/06/内存泄露/">Android内存泄露</a>
          </li>
        
          <li>
            <a href="/2016/11/02/Android-Bundle/">Bundle、Parcel解析</a>
          </li>
        
          <li>
            <a href="/2016/10/31/hello-world/">Java 动态代理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>